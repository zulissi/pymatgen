<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>pymatgen.io.abinit.tasks &mdash; pymatgen 3.3.0 documentation</title>
    
    <link rel="stylesheet" href="../../../../_static/proBlue.css" type="text/css" />
    <link rel="stylesheet" href="../../../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../../',
        VERSION:     '3.3.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../../_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="shortcut icon" href="../../../../_static/favicon.ico"/>
    <link rel="top" title="pymatgen 3.3.0 documentation" href="../../../../index.html" />
    <link rel="up" title="Module code" href="../../../index.html" />
 
<script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-33990148-1']);
  _gaq.push(['_trackPageview']);
</script>

  </head>
  <body role="document">
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../../index.html">pymatgen 3.3.0 documentation</a> &raquo;</li>
          <li class="nav-item nav-item-1"><a href="../../../index.html" accesskey="U">Module code</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for pymatgen.io.abinit.tasks</h1><div class="highlight"><pre>
<span class="c"># coding: utf-8</span>
<span class="c"># Copyright (c) Pymatgen Development Team.</span>
<span class="c"># Distributed under the terms of the MIT License.</span>
<span class="sd">&quot;&quot;&quot;This module provides functions and classes related to Task objects.&quot;&quot;&quot;</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">division</span><span class="p">,</span> <span class="n">print_function</span><span class="p">,</span> <span class="n">unicode_literals</span><span class="p">,</span> <span class="n">absolute_import</span>

<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">time</span>
<span class="kn">import</span> <span class="nn">datetime</span>
<span class="kn">import</span> <span class="nn">shutil</span>
<span class="kn">import</span> <span class="nn">collections</span>
<span class="kn">import</span> <span class="nn">abc</span>
<span class="kn">import</span> <span class="nn">copy</span>
<span class="kn">import</span> <span class="nn">yaml</span>
<span class="kn">import</span> <span class="nn">six</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>

<span class="kn">from</span> <span class="nn">pprint</span> <span class="kn">import</span> <span class="n">pprint</span>
<span class="kn">from</span> <span class="nn">six.moves</span> <span class="kn">import</span> <span class="nb">map</span><span class="p">,</span> <span class="nb">zip</span><span class="p">,</span> <span class="n">StringIO</span>
<span class="kn">from</span> <span class="nn">monty.string</span> <span class="kn">import</span> <span class="n">is_string</span><span class="p">,</span> <span class="n">list_strings</span>
<span class="kn">from</span> <span class="nn">monty.collections</span> <span class="kn">import</span> <span class="n">AttrDict</span>
<span class="kn">from</span> <span class="nn">monty.functools</span> <span class="kn">import</span> <span class="n">lazy_property</span><span class="p">,</span> <span class="n">return_none_if_raise</span>
<span class="kn">from</span> <span class="nn">monty.json</span> <span class="kn">import</span> <span class="n">MSONable</span>
<span class="kn">from</span> <span class="nn">monty.fnmatch</span> <span class="kn">import</span> <span class="n">WildCard</span>
<span class="kn">from</span> <span class="nn">pymatgen.core.units</span> <span class="kn">import</span> <span class="n">Memory</span>
<span class="kn">from</span> <span class="nn">pymatgen.serializers.json_coders</span> <span class="kn">import</span> <span class="n">json_pretty_dump</span><span class="p">,</span> <span class="n">pmg_serialize</span>
<span class="kn">from</span> <span class="nn">.utils</span> <span class="kn">import</span> <span class="n">File</span><span class="p">,</span> <span class="n">Directory</span><span class="p">,</span> <span class="n">irdvars_for_ext</span><span class="p">,</span> <span class="n">abi_splitext</span><span class="p">,</span> <span class="n">FilepathFixer</span><span class="p">,</span> <span class="n">Condition</span><span class="p">,</span> <span class="n">SparseHistogram</span>
<span class="kn">from</span> <span class="nn">.qadapters</span> <span class="kn">import</span> <span class="n">make_qadapter</span><span class="p">,</span> <span class="n">QueueAdapter</span><span class="p">,</span> <span class="n">QueueAdapterError</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">qutils</span> <span class="k">as</span> <span class="n">qu</span>
<span class="kn">from</span> <span class="nn">.db</span> <span class="kn">import</span> <span class="n">DBConnector</span>
<span class="kn">from</span> <span class="nn">.nodes</span> <span class="kn">import</span> <span class="n">Status</span><span class="p">,</span> <span class="n">Node</span><span class="p">,</span> <span class="n">NodeError</span><span class="p">,</span> <span class="n">NodeResults</span><span class="p">,</span> <span class="n">NodeCorrections</span><span class="p">,</span> <span class="n">FileNode</span><span class="p">,</span> <span class="n">check_spectator</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">abiinspect</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">events</span>


<span class="n">__author__</span> <span class="o">=</span> <span class="s">&quot;Matteo Giantomassi&quot;</span>
<span class="n">__copyright__</span> <span class="o">=</span> <span class="s">&quot;Copyright 2013, The Materials Project&quot;</span>
<span class="n">__version__</span> <span class="o">=</span> <span class="s">&quot;0.1&quot;</span>
<span class="n">__maintainer__</span> <span class="o">=</span> <span class="s">&quot;Matteo Giantomassi&quot;</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span>
    <span class="s">&quot;TaskManager&quot;</span><span class="p">,</span>
    <span class="s">&quot;ParalHintsParser&quot;</span><span class="p">,</span>
    <span class="s">&quot;ScfTask&quot;</span><span class="p">,</span>
    <span class="s">&quot;NscfTask&quot;</span><span class="p">,</span>
    <span class="s">&quot;RelaxTask&quot;</span><span class="p">,</span>
    <span class="s">&quot;DdkTask&quot;</span><span class="p">,</span>
    <span class="s">&quot;PhononTask&quot;</span><span class="p">,</span>
    <span class="s">&quot;SigmaTask&quot;</span><span class="p">,</span>
    <span class="s">&quot;OpticTask&quot;</span><span class="p">,</span>
    <span class="s">&quot;AnaddbTask&quot;</span><span class="p">,</span>
<span class="p">]</span>

<span class="kn">import</span> <span class="nn">logging</span>
<span class="n">logger</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="n">__name__</span><span class="p">)</span>

<span class="c"># Tools and helper functions.</span>

<span class="k">def</span> <span class="nf">straceback</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;Returns a string with the traceback.&quot;&quot;&quot;</span>
    <span class="kn">import</span> <span class="nn">traceback</span>
    <span class="k">return</span> <span class="n">traceback</span><span class="o">.</span><span class="n">format_exc</span><span class="p">()</span>

<span class="k">def</span> <span class="nf">nmltostring</span><span class="p">(</span><span class="n">nml</span><span class="p">):</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">nml</span><span class="p">,</span><span class="nb">dict</span><span class="p">):</span>
      <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;nml should be a dict !&quot;</span><span class="p">)</span>

    <span class="n">curstr</span> <span class="o">=</span> <span class="s">&quot;&quot;</span>
    <span class="k">for</span> <span class="n">key</span><span class="p">,</span><span class="n">group</span> <span class="ow">in</span> <span class="n">nml</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
       <span class="n">namelist</span> <span class="o">=</span> <span class="p">[</span><span class="s">&quot;&amp;&quot;</span><span class="o">+</span><span class="n">key</span><span class="p">]</span>
       <span class="k">for</span> <span class="n">k</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="n">group</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
         <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span><span class="nb">list</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span><span class="nb">tuple</span><span class="p">):</span>
           <span class="n">namelist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">k</span> <span class="o">+</span> <span class="s">&quot; = &quot;</span><span class="o">+</span><span class="s">&quot;,&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span><span class="n">v</span><span class="p">))</span><span class="o">+</span><span class="s">&quot;,&quot;</span><span class="p">)</span>
         <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span><span class="nb">unicode</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span><span class="nb">str</span><span class="p">):</span>
           <span class="n">namelist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">k</span> <span class="o">+</span> <span class="s">&quot; = &#39;&quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">v</span><span class="p">)</span><span class="o">+</span><span class="s">&quot;&#39;,&quot;</span><span class="p">)</span>
         <span class="k">else</span><span class="p">:</span>
           <span class="n">namelist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">k</span> <span class="o">+</span> <span class="s">&quot; = &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">v</span><span class="p">)</span><span class="o">+</span><span class="s">&quot;,&quot;</span><span class="p">)</span>
       <span class="n">namelist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s">&quot;/&quot;</span><span class="p">)</span>

       <span class="n">curstr</span> <span class="o">=</span> <span class="n">curstr</span> <span class="o">+</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">namelist</span><span class="p">)</span><span class="o">+</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span>

    <span class="k">return</span> <span class="n">curstr</span>

<span class="k">class</span> <span class="nc">TaskResults</span><span class="p">(</span><span class="n">NodeResults</span><span class="p">):</span>

    <span class="n">JSON_SCHEMA</span> <span class="o">=</span> <span class="n">NodeResults</span><span class="o">.</span><span class="n">JSON_SCHEMA</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span> 
    <span class="n">JSON_SCHEMA</span><span class="p">[</span><span class="s">&quot;properties&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s">&quot;executable&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s">&quot;type&quot;</span><span class="p">:</span> <span class="s">&quot;string&quot;</span><span class="p">,</span> <span class="s">&quot;required&quot;</span><span class="p">:</span> <span class="bp">True</span><span class="p">},</span>
    <span class="p">}</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_node</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">task</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialize an instance from an :class:`AbinitTask` instance.&quot;&quot;&quot;</span>
        <span class="n">new</span> <span class="o">=</span> <span class="nb">super</span><span class="p">(</span><span class="n">TaskResults</span><span class="p">,</span> <span class="n">cls</span><span class="p">)</span><span class="o">.</span><span class="n">from_node</span><span class="p">(</span><span class="n">task</span><span class="p">)</span>

        <span class="n">new</span><span class="o">.</span><span class="n">update</span><span class="p">(</span>
            <span class="n">executable</span><span class="o">=</span><span class="n">task</span><span class="o">.</span><span class="n">executable</span><span class="p">,</span>
            <span class="c">#executable_version:</span>
            <span class="c">#task_events=</span>
            <span class="n">pseudos</span><span class="o">=</span><span class="p">[</span><span class="n">p</span><span class="o">.</span><span class="n">as_dict</span><span class="p">()</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">task</span><span class="o">.</span><span class="n">input</span><span class="o">.</span><span class="n">pseudos</span><span class="p">],</span>
            <span class="c">#input=task.input</span>
        <span class="p">)</span>

        <span class="n">new</span><span class="o">.</span><span class="n">register_gridfs_files</span><span class="p">(</span>
            <span class="n">run_abi</span><span class="o">=</span><span class="p">(</span><span class="n">task</span><span class="o">.</span><span class="n">input_file</span><span class="o">.</span><span class="n">path</span><span class="p">,</span> <span class="s">&quot;t&quot;</span><span class="p">),</span>
            <span class="n">run_abo</span><span class="o">=</span><span class="p">(</span><span class="n">task</span><span class="o">.</span><span class="n">output_file</span><span class="o">.</span><span class="n">path</span><span class="p">,</span> <span class="s">&quot;t&quot;</span><span class="p">),</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="n">new</span>


<span class="k">class</span> <span class="nc">ParalConf</span><span class="p">(</span><span class="n">AttrDict</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This object store the parameters associated to one </span>
<span class="sd">    of the possible parallel configurations reported by ABINIT.</span>
<span class="sd">    Essentially it is a dictionary whose values can also be accessed </span>
<span class="sd">    as attributes. It also provides default values for selected keys</span>
<span class="sd">    that might not be present in the ABINIT dictionary.</span>

<span class="sd">    Example:</span>

<span class="sd">        --- !Autoparal</span>
<span class="sd">        info: </span>
<span class="sd">            version: 1</span>
<span class="sd">            autoparal: 1</span>
<span class="sd">            max_ncpus: 108</span>
<span class="sd">        configurations:</span>
<span class="sd">            -   tot_ncpus: 2         # Total number of CPUs</span>
<span class="sd">                mpi_ncpus: 2         # Number of MPI processes.</span>
<span class="sd">                omp_ncpus: 1         # Number of OMP threads (1 if not present)</span>
<span class="sd">                mem_per_cpu: 10      # Estimated memory requirement per MPI processor in Megabytes.</span>
<span class="sd">                efficiency: 0.4      # 1.0 corresponds to an &quot;expected&quot; optimal efficiency (strong scaling).</span>
<span class="sd">                vars: {              # Dictionary with the variables that should be added to the input.</span>
<span class="sd">                      varname1: varvalue1</span>
<span class="sd">                      varname2: varvalue2</span>
<span class="sd">                      }</span>
<span class="sd">            -</span>
<span class="sd">        ...</span>

<span class="sd">    For paral_kgb we have:</span>
<span class="sd">    nproc     npkpt  npspinor    npband     npfft    bandpp    weight   </span>
<span class="sd">       108       1         1        12         9         2        0.25</span>
<span class="sd">       108       1         1       108         1         2       27.00</span>
<span class="sd">        96       1         1        24         4         1        1.50</span>
<span class="sd">        84       1         1        12         7         2        0.25</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">_DEFAULTS</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s">&quot;omp_ncpus&quot;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>     
        <span class="s">&quot;mem_per_cpu&quot;</span><span class="p">:</span> <span class="mf">0.0</span><span class="p">,</span> 
        <span class="s">&quot;vars&quot;</span><span class="p">:</span> <span class="p">{}</span>       
    <span class="p">}</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">ParalConf</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        
        <span class="c"># Add default values if not already in self.</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_DEFAULTS</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">k</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
                <span class="bp">self</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">stream</span> <span class="o">=</span> <span class="n">StringIO</span><span class="p">()</span>
        <span class="n">pprint</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stream</span><span class="o">=</span><span class="n">stream</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">stream</span><span class="o">.</span><span class="n">getvalue</span><span class="p">()</span>

    <span class="c"># TODO: Change name in abinit</span>
    <span class="c"># Remove tot_ncpus from Abinit</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">num_cores</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">mpi_procs</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">omp_threads</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">mem_per_proc</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">mem_per_cpu</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">mpi_procs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">mpi_ncpus</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">omp_threads</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">omp_ncpus</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">speedup</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Estimated speedup reported by ABINIT.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">efficiency</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_cores</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">tot_mem</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Estimated total memory in Mbs (computed from mem_per_proc)&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">mem_per_proc</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">mpi_procs</span>


<span class="k">class</span> <span class="nc">ParalHintsError</span><span class="p">(</span><span class="ne">Exception</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Base error class for `ParalHints`.&quot;&quot;&quot;</span>


<div class="viewcode-block" id="ParalHintsParser"><a class="viewcode-back" href="../../../../pymatgen.io.abinit.html#pymatgen.io.abinit.tasks.ParalHintsParser">[docs]</a><span class="k">class</span> <span class="nc">ParalHintsParser</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span></div>

    <span class="n">Error</span> <span class="o">=</span> <span class="n">ParalHintsError</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c"># Used to push error strings.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_errors</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">deque</span><span class="p">(</span><span class="n">maxlen</span><span class="o">=</span><span class="mi">100</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">add_error</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">errmsg</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_errors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">errmsg</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">parse</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Read the `AutoParal` section (YAML format) from filename.</span>
<span class="sd">        Assumes the file contains only one section.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">with</span> <span class="n">abiinspect</span><span class="o">.</span><span class="n">YamlTokenizer</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span> <span class="k">as</span> <span class="n">r</span><span class="p">:</span>
            <span class="n">doc</span> <span class="o">=</span> <span class="n">r</span><span class="o">.</span><span class="n">next_doc_with_tag</span><span class="p">(</span><span class="s">&quot;!Autoparal&quot;</span><span class="p">)</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">d</span> <span class="o">=</span> <span class="n">yaml</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">doc</span><span class="o">.</span><span class="n">text_notag</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">ParalHints</span><span class="p">(</span><span class="n">info</span><span class="o">=</span><span class="n">d</span><span class="p">[</span><span class="s">&quot;info&quot;</span><span class="p">],</span> <span class="n">confs</span><span class="o">=</span><span class="n">d</span><span class="p">[</span><span class="s">&quot;configurations&quot;</span><span class="p">])</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="kn">import</span> <span class="nn">traceback</span>
                <span class="n">sexc</span> <span class="o">=</span> <span class="n">traceback</span><span class="o">.</span><span class="n">format_exc</span><span class="p">()</span>
                <span class="n">err_msg</span> <span class="o">=</span> <span class="s">&quot;Wrong YAML doc:</span><span class="se">\n</span><span class="si">%s</span><span class="se">\n\n</span><span class="s">Exception:</span><span class="se">\n</span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">doc</span><span class="o">.</span><span class="n">text</span><span class="p">,</span> <span class="n">sexc</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">add_error</span><span class="p">(</span><span class="n">err_msg</span><span class="p">)</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">critical</span><span class="p">(</span><span class="n">err_msg</span><span class="p">)</span>
                <span class="k">raise</span> <span class="bp">self</span><span class="o">.</span><span class="n">Error</span><span class="p">(</span><span class="n">err_msg</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">ParalHints</span><span class="p">(</span><span class="n">collections</span><span class="o">.</span><span class="n">Iterable</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Iterable with the hints for the parallel execution reported by ABINIT.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">Error</span> <span class="o">=</span> <span class="n">ParalHintsError</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">info</span><span class="p">,</span> <span class="n">confs</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">info</span> <span class="o">=</span> <span class="n">info</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_confs</span> <span class="o">=</span> <span class="p">[</span><span class="n">ParalConf</span><span class="p">(</span><span class="o">**</span><span class="n">d</span><span class="p">)</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">confs</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_confs</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_confs</span><span class="o">.</span><span class="n">__iter__</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_confs</span><span class="o">.</span><span class="n">__len__</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">conf</span><span class="p">)</span> <span class="k">for</span> <span class="n">conf</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="nd">@lazy_property</span>
    <span class="k">def</span> <span class="nf">max_cores</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Maximum number of cores.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">max</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">mpi_procs</span> <span class="o">*</span> <span class="n">c</span><span class="o">.</span><span class="n">omp_threads</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">)</span>

    <span class="nd">@lazy_property</span>
    <span class="k">def</span> <span class="nf">max_mem_per_proc</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Maximum memory per MPI process.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">max</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">mem_per_proc</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">)</span> 

    <span class="nd">@lazy_property</span>
    <span class="k">def</span> <span class="nf">max_speedup</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Maximum speedup.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">max</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">speedup</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">)</span> 

    <span class="nd">@lazy_property</span>
    <span class="k">def</span> <span class="nf">max_efficiency</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Maximum parallel efficiency.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">max</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">efficiency</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">)</span> 

    <span class="nd">@pmg_serialize</span>
    <span class="k">def</span> <span class="nf">as_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">{</span><span class="s">&quot;info&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">,</span> <span class="s">&quot;confs&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_confs</span><span class="p">}</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_dict</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">d</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">cls</span><span class="p">(</span><span class="n">info</span><span class="o">=</span><span class="n">d</span><span class="p">[</span><span class="s">&quot;info&quot;</span><span class="p">],</span> <span class="n">confs</span><span class="o">=</span><span class="n">d</span><span class="p">[</span><span class="s">&quot;confs&quot;</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Shallow copy of self.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">select_with_condition</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">condition</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Remove all the configurations that do not satisfy the given condition.</span>

<span class="sd">            Args:</span>
<span class="sd">                condition: dict or :class:`Condition` object with operators expressed with a Mongodb-like syntax</span>
<span class="sd">                key: Selects the sub-dictionary on which condition is applied, e.g. key=&quot;vars&quot;</span>
<span class="sd">                    if we have to filter the configurations depending on the values in vars</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">condition</span> <span class="o">=</span> <span class="n">Condition</span><span class="o">.</span><span class="n">as_condition</span><span class="p">(</span><span class="n">condition</span><span class="p">)</span>
        <span class="n">new_confs</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">conf</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="c"># Select the object on which condition is applied</span>
            <span class="n">obj</span> <span class="o">=</span> <span class="n">conf</span> <span class="k">if</span> <span class="n">key</span> <span class="ow">is</span> <span class="bp">None</span> <span class="k">else</span> <span class="n">AttrDict</span><span class="p">(</span><span class="n">conf</span><span class="p">[</span><span class="n">key</span><span class="p">])</span>
            <span class="n">add_it</span> <span class="o">=</span> <span class="n">condition</span><span class="p">(</span><span class="n">obj</span><span class="o">=</span><span class="n">obj</span><span class="p">)</span>
            <span class="c">#if key is &quot;vars&quot;: print(&quot;conf&quot;, conf, &quot;added:&quot;, add_it)</span>
            <span class="k">if</span> <span class="n">add_it</span><span class="p">:</span> <span class="n">new_confs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">conf</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_confs</span> <span class="o">=</span> <span class="n">new_confs</span>

    <span class="k">def</span> <span class="nf">sort_by_efficiency</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Sort the configurations in place. items with highest efficiency come first&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_confs</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">c</span><span class="p">:</span> <span class="n">c</span><span class="o">.</span><span class="n">efficiency</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="n">reverse</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">sort_by_speedup</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Sort the configurations in place. items with highest speedup come first&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_confs</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">c</span><span class="p">:</span> <span class="n">c</span><span class="o">.</span><span class="n">speedup</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="n">reverse</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">sort_by_mem_per_proc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Sort the configurations in place. items with lowest memory per proc come first.&quot;&quot;&quot;</span>
        <span class="c"># Avoid sorting if mem_per_cpu is not available.</span>
        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">mem_per_proc</span> <span class="o">&gt;</span> <span class="mf">0.0</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_confs</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">c</span><span class="p">:</span> <span class="n">c</span><span class="o">.</span><span class="n">mem_per_proc</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="n">reverse</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">multidimensional_optimization</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">priorities</span><span class="o">=</span><span class="p">(</span><span class="s">&quot;speedup&quot;</span><span class="p">,</span> <span class="s">&quot;efficiency&quot;</span><span class="p">)):</span>
        <span class="c"># Mapping property --&gt; options passed to sparse_histogram</span>
        <span class="n">opts</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">speedup</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">step</span><span class="o">=</span><span class="mf">1.0</span><span class="p">),</span> <span class="n">efficiency</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">step</span><span class="o">=</span><span class="mf">0.1</span><span class="p">),</span> <span class="n">mem_per_proc</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">memory</span><span class="o">=</span><span class="mi">1024</span><span class="p">))</span>
        <span class="c">#opts = dict(zip(priorities, bin_widths))</span>
                                                                                                   
        <span class="n">opt_confs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_confs</span>
        <span class="k">for</span> <span class="n">priority</span> <span class="ow">in</span> <span class="n">priorities</span><span class="p">:</span>
            <span class="n">histogram</span> <span class="o">=</span> <span class="n">SparseHistogram</span><span class="p">(</span><span class="n">opt_confs</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">c</span><span class="p">:</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">priority</span><span class="p">),</span> <span class="o">**</span><span class="n">opts</span><span class="p">[</span><span class="n">priority</span><span class="p">])</span>
            <span class="n">pos</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">if</span> <span class="n">priority</span> <span class="o">==</span> <span class="s">&quot;mem_per_proc&quot;</span> <span class="k">else</span> <span class="o">-</span><span class="mi">1</span>
            <span class="n">opt_confs</span> <span class="o">=</span> <span class="n">histogram</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span>

        <span class="c">#histogram.plot(show=True, savefig=&quot;hello.pdf&quot;)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="p">(</span><span class="n">info</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">,</span> <span class="n">confs</span><span class="o">=</span><span class="n">opt_confs</span><span class="p">)</span>

    <span class="c">#def histogram_efficiency(self, step=0.1):</span>
    <span class="c">#    &quot;&quot;&quot;Returns a :class:`SparseHistogram` with configuration grouped by parallel efficiency.&quot;&quot;&quot;</span>
    <span class="c">#    return SparseHistogram(self._confs, key=lambda c: c.efficiency, step=step)</span>

    <span class="c">#def histogram_speedup(self, step=1.0):</span>
    <span class="c">#    &quot;&quot;&quot;Returns a :class:`SparseHistogram` with configuration grouped by parallel speedup.&quot;&quot;&quot;</span>
    <span class="c">#    return SparseHistogram(self._confs, key=lambda c: c.speedup, step=step)</span>

    <span class="c">#def histogram_memory(self, step=1024):</span>
    <span class="c">#    &quot;&quot;&quot;Returns a :class:`SparseHistogram` with configuration grouped by memory.&quot;&quot;&quot;</span>
    <span class="c">#    return SparseHistogram(self._confs, key=lambda c: c.speedup, step=step)</span>

    <span class="c">#def filter(self, qadapter):</span>
    <span class="c">#    &quot;&quot;&quot;Return a new list of configurations that can be executed on the `QueueAdapter` qadapter.&quot;&quot;&quot;</span>
    <span class="c">#    new_confs = [pconf for pconf in self if qadapter.can_run_pconf(pconf)]</span>
    <span class="c">#    return self.__class__(info=self.info, confs=new_confs)</span>

    <span class="k">def</span> <span class="nf">get_ordered_with_policy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">policy</span><span class="p">,</span> <span class="n">max_ncpus</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sort and return a new list of configurations ordered according to the :class:`TaskPolicy` policy.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># Build new list since we are gonna change the object in place.</span>
        <span class="n">hints</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">,</span> <span class="n">confs</span><span class="o">=</span><span class="p">[</span><span class="n">c</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span> <span class="k">if</span> <span class="n">c</span><span class="o">.</span><span class="n">num_cores</span> <span class="o">&lt;=</span> <span class="n">max_ncpus</span><span class="p">])</span>

        <span class="c"># First select the configurations satisfying the condition specified by the user (if any)</span>
        <span class="n">bkp_hints</span> <span class="o">=</span> <span class="n">hints</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">policy</span><span class="o">.</span><span class="n">condition</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s">&quot;Applying condition </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="n">policy</span><span class="o">.</span><span class="n">condition</span><span class="p">))</span>
            <span class="n">hints</span><span class="o">.</span><span class="n">select_with_condition</span><span class="p">(</span><span class="n">policy</span><span class="o">.</span><span class="n">condition</span><span class="p">)</span>

            <span class="c"># Undo change if no configuration fullfills the requirements.</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">hints</span><span class="p">:</span>
                <span class="n">hints</span> <span class="o">=</span> <span class="n">bkp_hints</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s">&quot;Empty list of configurations after policy.condition&quot;</span><span class="p">)</span>

        <span class="c"># Now filter the configurations depending on the values in vars</span>
        <span class="n">bkp_hints</span> <span class="o">=</span> <span class="n">hints</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">policy</span><span class="o">.</span><span class="n">vars_condition</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s">&quot;Applying vars_condition </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="n">policy</span><span class="o">.</span><span class="n">vars_condition</span><span class="p">))</span>
            <span class="n">hints</span><span class="o">.</span><span class="n">select_with_condition</span><span class="p">(</span><span class="n">policy</span><span class="o">.</span><span class="n">vars_condition</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s">&quot;vars&quot;</span><span class="p">)</span>

            <span class="c"># Undo change if no configuration fullfills the requirements.</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">hints</span><span class="p">:</span>
                <span class="n">hints</span> <span class="o">=</span> <span class="n">bkp_hints</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s">&quot;Empty list of configurations after policy.vars_condition&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">policy</span><span class="o">.</span><span class="n">autoparal_priorities</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c"># Example: hints.sort_by_speedup()</span>
            <span class="k">if</span> <span class="n">policy</span><span class="o">.</span><span class="n">autoparal_priorities</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="p">[</span><span class="s">&#39;efficiency&#39;</span><span class="p">,</span> <span class="s">&#39;speedup&#39;</span><span class="p">,</span> <span class="s">&#39;mem_per_proc&#39;</span><span class="p">]:</span>
                <span class="nb">getattr</span><span class="p">(</span><span class="n">hints</span><span class="p">,</span> <span class="s">&quot;sort_by_&quot;</span> <span class="o">+</span> <span class="n">policy</span><span class="o">.</span><span class="n">autoparal_priorities</span><span class="p">[</span><span class="mi">0</span><span class="p">])()</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">policy</span><span class="o">.</span><span class="n">autoparal_priorities</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">collections</span><span class="o">.</span><span class="n">Mapping</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">policy</span><span class="o">.</span><span class="n">autoparal_priorities</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s">&#39;meta_priority&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s">&#39;highest_speedup_minimum_efficiency_cutoff&#39;</span><span class="p">:</span>
                    <span class="n">min_efficiency</span> <span class="o">=</span> <span class="n">policy</span><span class="o">.</span><span class="n">autoparal_priorities</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;minimum_efficiency&#39;</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)</span>
                    <span class="n">hints</span><span class="o">.</span><span class="n">select_with_condition</span><span class="p">({</span><span class="s">&#39;efficiency&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s">&#39;$gte&#39;</span><span class="p">:</span> <span class="n">min_efficiency</span><span class="p">}})</span>
                    <span class="n">hints</span><span class="o">.</span><span class="n">sort_by_speedup</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">hints</span> <span class="o">=</span> <span class="n">hints</span><span class="o">.</span><span class="n">multidimensional_optimization</span><span class="p">(</span><span class="n">priorities</span><span class="o">=</span><span class="n">policy</span><span class="o">.</span><span class="n">autoparal_priorities</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">hints</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;len(hints) == 0&quot;</span><span class="p">)</span>

        <span class="c">#TODO: make sure that num_cores == 1 is never selected when we have more than one configuration</span>
        <span class="c">#if len(hints) &gt; 1:</span>
        <span class="c">#    hints.select_with_condition(dict(num_cores={&quot;$eq&quot;: 1)))</span>

        <span class="c"># Return final (orderded ) list of configurations (best first).</span>
        <span class="k">return</span> <span class="n">hints</span>


<span class="k">class</span> <span class="nc">TaskPolicy</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This object stores the parameters used by the :class:`TaskManager` to </span>
<span class="sd">    create the submission script and/or to modify the ABINIT variables </span>
<span class="sd">    governing the parallel execution. A `TaskPolicy` object contains </span>
<span class="sd">    a set of variables that specify the launcher, as well as the options</span>
<span class="sd">    and the conditions used to select the optimal configuration for the parallel run </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">as_policy</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">obj</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Converts an object obj into a `:class:`TaskPolicy. Accepts:</span>

<span class="sd">            * None</span>
<span class="sd">            * TaskPolicy</span>
<span class="sd">            * dict-like object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">obj</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="c"># Use default policy.</span>
            <span class="k">return</span> <span class="n">TaskPolicy</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">cls</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">obj</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">collections</span><span class="o">.</span><span class="n">Mapping</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">cls</span><span class="p">(</span><span class="o">**</span><span class="n">obj</span><span class="p">)</span> 
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&quot;Don&#39;t know how to convert type </span><span class="si">%s</span><span class="s"> to </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">obj</span><span class="p">),</span> <span class="n">cls</span><span class="p">))</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">autodoc</span><span class="p">(</span><span class="n">cls</span><span class="p">):</span>
        <span class="k">return</span> <span class="s">&quot;&quot;&quot;</span>
<span class="s">    autoparal: 0 to disable the autoparal feature (default 1 i.e. autoparal is on)</span>
<span class="s">    condition: condition used to filter the autoparal configurations (Mongodb-like syntax). </span>
<span class="s">               Default: empty </span>
<span class="s">    vars_condition: condition used to filter the list of ABINIT variables reported autoparal </span>
<span class="s">                    (Mongodb-like syntax). Default: empty</span>
<span class="s">    frozen_timeout: A job is considered to be frozen and its status is set to Error if no change to </span>
<span class="s">                    the output file has been done for frozen_timeout seconds. Accepts int with seconds or </span>
<span class="s">                    string in slurm form i.e. days-hours:minutes:seconds. Default: 1 hour.</span>
<span class="s">    precedence:</span>
<span class="s">    autoparal_priorities:</span>
<span class="s">&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        See autodoc</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">autoparal</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s">&quot;autoparal&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">condition</span> <span class="o">=</span> <span class="n">Condition</span><span class="p">(</span><span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s">&quot;condition&quot;</span><span class="p">,</span> <span class="p">{}))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">vars_condition</span> <span class="o">=</span> <span class="n">Condition</span><span class="p">(</span><span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s">&quot;vars_condition&quot;</span><span class="p">,</span> <span class="p">{}))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">precedence</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s">&quot;precedence&quot;</span><span class="p">,</span> <span class="s">&quot;autoparal_conf&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">autoparal_priorities</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s">&quot;autoparal_priorities&quot;</span><span class="p">,</span> <span class="p">[</span><span class="s">&quot;speedup&quot;</span><span class="p">])</span>
        <span class="c">#self.autoparal_priorities = kwargs.pop(&quot;autoparal_priorities&quot;, [&quot;speedup&quot;, &quot;efficiecy&quot;, &quot;memory&quot;]</span>
        <span class="c"># TODO frozen_timeout could be computed as a fraction of the timelimit of the qadapter!</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">frozen_timeout</span> <span class="o">=</span> <span class="n">qu</span><span class="o">.</span><span class="n">slurm_parse_timestr</span><span class="p">(</span><span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s">&quot;frozen_timeout&quot;</span><span class="p">,</span> <span class="s">&quot;0-1&quot;</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;Found invalid keywords in policy section:</span><span class="se">\n</span><span class="s"> </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="n">kwargs</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span>

        <span class="c"># Consistency check.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">precedence</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="s">&quot;qadapter&quot;</span><span class="p">,</span> <span class="s">&quot;autoparal_conf&quot;</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;Wrong value for policy.precedence, should be qadapter or autoparal_conf&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">lines</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">app</span> <span class="o">=</span> <span class="n">lines</span><span class="o">.</span><span class="n">append</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__dict__</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">k</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s">&quot;_&quot;</span><span class="p">):</span> <span class="k">continue</span>
            <span class="n">app</span><span class="p">(</span><span class="s">&quot;</span><span class="si">%s</span><span class="s">: </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">))</span>
        <span class="k">return</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">lines</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">ManagerIncreaseError</span><span class="p">(</span><span class="ne">Exception</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Exception raised by the manager if the increase request failed</span>
<span class="sd">    &quot;&quot;&quot;</span>


<span class="k">class</span> <span class="nc">FixQueueCriticalError</span><span class="p">(</span><span class="ne">Exception</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    error raised when an error could not be fixed at the task level</span>
<span class="sd">    &quot;&quot;&quot;</span>


<span class="c"># Global variable used to store the task manager returned by `from_user_config`.</span>
<span class="n">_USER_CONFIG_TASKMANAGER</span> <span class="o">=</span> <span class="bp">None</span>


<div class="viewcode-block" id="TaskManager"><a class="viewcode-back" href="../../../../pymatgen.io.abinit.html#pymatgen.io.abinit.tasks.TaskManager">[docs]</a><span class="k">class</span> <span class="nc">TaskManager</span><span class="p">(</span><span class="n">MSONable</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A `TaskManager` is responsible for the generation of the job script and the submission </span>
<span class="sd">    of the task, as well as for the specification of the parameters passed to the resource manager</span>
<span class="sd">    (e.g. Slurm, PBS ...) and/or the run-time specification of the ABINIT variables governing the parallel execution. </span>
<span class="sd">    A `TaskManager` delegates the generation of the submission script and the submission of the task to the :class:`QueueAdapter`. </span>
<span class="sd">    A `TaskManager` has a :class:`TaskPolicy` that governs the specification of the parameters for the parallel executions.</span>
<span class="sd">    Ideally, the TaskManager should be the **main entry point** used by the task to deal with job submission/optimization</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">YAML_FILE</span> <span class="o">=</span> <span class="s">&quot;manager.yml&quot;</span>
    <span class="n">USER_CONFIG_DIR</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">getenv</span><span class="p">(</span><span class="s">&quot;HOME&quot;</span><span class="p">),</span> <span class="s">&quot;.abinit&quot;</span><span class="p">,</span> <span class="s">&quot;abipy&quot;</span><span class="p">)</span>

    <span class="n">ENTRIES</span> <span class="o">=</span> <span class="p">{</span><span class="s">&quot;policy&quot;</span><span class="p">,</span> <span class="s">&quot;qadapters&quot;</span><span class="p">,</span> <span class="s">&quot;db_connector&quot;</span><span class="p">,</span> <span class="s">&quot;batch_adapter&quot;</span><span class="p">}</span>

    <span class="nd">@classmethod</span>
<div class="viewcode-block" id="TaskManager.autodoc"><a class="viewcode-back" href="../../../../pymatgen.io.abinit.html#pymatgen.io.abinit.tasks.TaskManager.autodoc">[docs]</a>    <span class="k">def</span> <span class="nf">autodoc</span><span class="p">(</span><span class="n">cls</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">.db</span> <span class="kn">import</span> <span class="n">DBConnector</span>
        <span class="n">s</span> <span class="o">=</span> <span class="s">&quot;&quot;&quot;</span>
<span class="s"># TaskManager configuration file (YAML Format)</span>

<span class="s">policy: </span>
<span class="s">    # Dictionary with options used to control the execution of the tasks.</span>

<span class="s">qadapters:  </span>
<span class="s">    # List of qadapters objects (mandatory)</span>
<span class="s">    -  # qadapter_1</span>
<span class="s">    -  # qadapter_2</span>

<span class="s">db_connector: </span>
<span class="s">    # Connection to MongoDB database (optional)</span>

<span class="s">batch_adapter: </span>
<span class="s">    # Adapter used to submit flows with batch script. (optional)</span>

<span class="s">##########################################</span>
<span class="s"># Individual entries are documented below:</span>
<span class="s">##########################################</span>

<span class="s">&quot;&quot;&quot;</span>
        <span class="n">s</span> <span class="o">+=</span> <span class="s">&quot;policy: &quot;</span> <span class="o">+</span> <span class="n">TaskPolicy</span><span class="o">.</span><span class="n">autodoc</span><span class="p">()</span> <span class="o">+</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span>
        <span class="n">s</span> <span class="o">+=</span> <span class="s">&quot;qadapter: &quot;</span> <span class="o">+</span> <span class="n">QueueAdapter</span><span class="o">.</span><span class="n">autodoc</span><span class="p">()</span> <span class="o">+</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span>
        <span class="n">s</span> <span class="o">+=</span> <span class="s">&quot;db_connector: &quot;</span> <span class="o">+</span> <span class="n">DBConnector</span><span class="o">.</span><span class="n">autodoc</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">s</span></div>

    <span class="nd">@classmethod</span>
<div class="viewcode-block" id="TaskManager.from_user_config"><a class="viewcode-back" href="../../../../pymatgen.io.abinit.html#pymatgen.io.abinit.tasks.TaskManager.from_user_config">[docs]</a>    <span class="k">def</span> <span class="nf">from_user_config</span><span class="p">(</span><span class="n">cls</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialize the :class:`TaskManager` from the YAML file &#39;manager.yaml&#39;.</span>
<span class="sd">        Search first in the working directory and then in the abipy configuration directory.</span>

<span class="sd">        Raises:</span>
<span class="sd">            RuntimeError if file is not found.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">global</span> <span class="n">_USER_CONFIG_TASKMANAGER</span>
        <span class="k">if</span> <span class="n">_USER_CONFIG_TASKMANAGER</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">_USER_CONFIG_TASKMANAGER</span>

        <span class="c"># Try in the current directory then in user configuration directory.</span>
        <span class="n">path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">getcwd</span><span class="p">(),</span> <span class="n">cls</span><span class="o">.</span><span class="n">YAML_FILE</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">path</span><span class="p">):</span>
            <span class="n">path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">cls</span><span class="o">.</span><span class="n">USER_CONFIG_DIR</span><span class="p">,</span> <span class="n">cls</span><span class="o">.</span><span class="n">YAML_FILE</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">path</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s">&quot;Cannot locate </span><span class="si">%s</span><span class="s"> neither in current directory nor in </span><span class="si">%s</span><span class="se">\n</span><span class="s">&quot;</span>
                               <span class="s">&quot; !!! PLEASE READ THIS : !!! </span><span class="se">\n</span><span class="s">&quot;</span>
                               <span class="s">&quot;To use abipy to run jobs this file needs be be present</span><span class="se">\n</span><span class="s">&quot;</span>
                               <span class="s">&quot;it provides a description of the cluster/computer you are running on</span><span class="se">\n</span><span class="s">&quot;</span>
                               <span class="s">&quot;Examples are provided in abipy/data/managers.&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">cls</span><span class="o">.</span><span class="n">YAML_FILE</span><span class="p">,</span> <span class="n">path</span><span class="p">))</span>

        <span class="n">_USER_CONFIG_TASKMANAGER</span> <span class="o">=</span> <span class="n">cls</span><span class="o">.</span><span class="n">from_file</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">_USER_CONFIG_TASKMANAGER</span> </div>

    <span class="nd">@classmethod</span>
<div class="viewcode-block" id="TaskManager.from_file"><a class="viewcode-back" href="../../../../pymatgen.io.abinit.html#pymatgen.io.abinit.tasks.TaskManager.from_file">[docs]</a>    <span class="k">def</span> <span class="nf">from_file</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">filename</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Read the configuration parameters from the Yaml file filename.&quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s">&quot;r&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">fh</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">cls</span><span class="o">.</span><span class="n">from_dict</span><span class="p">(</span><span class="n">yaml</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">fh</span><span class="p">))</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">exc</span><span class="p">:</span>
            <span class="k">print</span><span class="p">(</span><span class="s">&quot;Error while reading TaskManager parameters from </span><span class="si">%s</span><span class="se">\n</span><span class="s">&quot;</span> <span class="o">%</span> <span class="n">filename</span><span class="p">)</span>
            <span class="k">raise</span> </div>

    <span class="nd">@classmethod</span>
<div class="viewcode-block" id="TaskManager.from_string"><a class="viewcode-back" href="../../../../pymatgen.io.abinit.html#pymatgen.io.abinit.tasks.TaskManager.from_string">[docs]</a>    <span class="k">def</span> <span class="nf">from_string</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">s</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create an instance from string s containing a YAML dictionary.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">cls</span><span class="o">.</span><span class="n">from_dict</span><span class="p">(</span><span class="n">yaml</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">s</span><span class="p">))</span></div>

    <span class="nd">@classmethod</span>
<div class="viewcode-block" id="TaskManager.as_manager"><a class="viewcode-back" href="../../../../pymatgen.io.abinit.html#pymatgen.io.abinit.tasks.TaskManager.as_manager">[docs]</a>    <span class="k">def</span> <span class="nf">as_manager</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">obj</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert obj into TaskManager instance. Accepts string, filepath, dictionary, `TaskManager` object.</span>
<span class="sd">        If obj is None, the manager is initialized from the user config file.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">cls</span><span class="p">):</span> <span class="k">return</span> <span class="n">obj</span>
        <span class="k">if</span> <span class="n">obj</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span> <span class="k">return</span> <span class="n">cls</span><span class="o">.</span><span class="n">from_user_config</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">is_string</span><span class="p">(</span><span class="n">obj</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">obj</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">cls</span><span class="o">.</span><span class="n">from_file</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">cls</span><span class="o">.</span><span class="n">from_string</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>

        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">collections</span><span class="o">.</span><span class="n">Mapping</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">cls</span><span class="o">.</span><span class="n">from_dict</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&quot;Don&#39;t know how to convert type </span><span class="si">%s</span><span class="s"> to TaskManager&quot;</span> <span class="o">%</span> <span class="nb">type</span><span class="p">(</span><span class="n">obj</span><span class="p">))</span></div>

    <span class="nd">@classmethod</span>
<div class="viewcode-block" id="TaskManager.from_dict"><a class="viewcode-back" href="../../../../pymatgen.io.abinit.html#pymatgen.io.abinit.tasks.TaskManager.from_dict">[docs]</a>    <span class="k">def</span> <span class="nf">from_dict</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">d</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create an instance from a dictionary.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">cls</span><span class="p">(</span><span class="o">**</span><span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">d</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">cls</span><span class="o">.</span><span class="n">ENTRIES</span><span class="p">})</span></div>

    <span class="nd">@pmg_serialize</span>
<div class="viewcode-block" id="TaskManager.as_dict"><a class="viewcode-back" href="../../../../pymatgen.io.abinit.html#pymatgen.io.abinit.tasks.TaskManager.as_dict">[docs]</a>    <span class="k">def</span> <span class="nf">as_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_kwargs</span></div>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Args:</span>
<span class="sd">            policy:None</span>
<span class="sd">            qadapters:List of qadapters in YAML format</span>
<span class="sd">            db_connector:Dictionary with data used to connect to the database (optional)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># Keep a copy of kwargs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_kwargs</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">policy</span> <span class="o">=</span> <span class="n">TaskPolicy</span><span class="o">.</span><span class="n">as_policy</span><span class="p">(</span><span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s">&quot;policy&quot;</span><span class="p">,</span> <span class="bp">None</span><span class="p">))</span>

        <span class="c"># Initialize database connector (if specified)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">db_connector</span> <span class="o">=</span> <span class="n">DBConnector</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s">&quot;db_connector&quot;</span><span class="p">,</span> <span class="p">{}))</span>

        <span class="c"># Build list of QAdapters. Neglect entry if priority == 0 or `enabled: no&quot;</span>
        <span class="n">qads</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s">&quot;qadapters&quot;</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">d</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&quot;enabled&quot;</span><span class="p">,</span> <span class="bp">False</span><span class="p">):</span> <span class="k">continue</span> 
            <span class="n">qad</span> <span class="o">=</span> <span class="n">make_qadapter</span><span class="p">(</span><span class="o">**</span><span class="n">d</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">qad</span><span class="o">.</span><span class="n">priority</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>    
                <span class="n">qads</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">qad</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">qad</span><span class="o">.</span><span class="n">priority</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>    
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;qadapter cannot have negative priority:</span><span class="se">\n</span><span class="s"> </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="n">qad</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">qads</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;Received emtpy list of qadapters&quot;</span><span class="p">)</span>
        <span class="c">#if len(qads) != 1:</span>
        <span class="c">#    raise NotImplementedError(&quot;For the time being multiple qadapters are not supported! Please use one adapter&quot;)</span>

        <span class="c"># Order qdapters according to priority.</span>
        <span class="n">qads</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">qads</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">q</span><span class="p">:</span> <span class="n">q</span><span class="o">.</span><span class="n">priority</span><span class="p">)</span>
        <span class="n">priorities</span> <span class="o">=</span> <span class="p">[</span><span class="n">q</span><span class="o">.</span><span class="n">priority</span> <span class="k">for</span> <span class="n">q</span> <span class="ow">in</span> <span class="n">qads</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">priorities</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">priorities</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;Two or more qadapters have same priority. This is not allowed. Check taskmanager.yml&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_qads</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_qadpos</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">qads</span><span class="p">),</span> <span class="mi">0</span>

        <span class="c"># Initialize the qadapter for batch script submission.</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s">&quot;batch_adapter&quot;</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">batch_adapter</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="k">if</span> <span class="n">d</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">batch_adapter</span> <span class="o">=</span> <span class="n">make_qadapter</span><span class="p">(</span><span class="o">**</span><span class="n">d</span><span class="p">)</span>
        <span class="c">#print(&quot;batch_adapter&quot;, self.batch_adapter)</span>

        <span class="k">if</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;Found invalid keywords in the taskmanager file:</span><span class="se">\n</span><span class="s"> </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">kwargs</span><span class="o">.</span><span class="n">keys</span><span class="p">())))</span>

<div class="viewcode-block" id="TaskManager.to_shell_manager"><a class="viewcode-back" href="../../../../pymatgen.io.abinit.html#pymatgen.io.abinit.tasks.TaskManager.to_shell_manager">[docs]</a>    <span class="k">def</span> <span class="nf">to_shell_manager</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mpi_procs</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a new `TaskManager` with the same parameters as self but replace the :class:`QueueAdapter`</span>
<span class="sd">        with a :class:`ShellAdapter` with mpi_procs so that we can submit the job without passing through the queue.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">my_kwargs</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_kwargs</span><span class="p">)</span>
        <span class="n">my_kwargs</span><span class="p">[</span><span class="s">&quot;policy&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">TaskPolicy</span><span class="p">(</span><span class="n">autoparal</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">my_kwargs</span><span class="p">[</span><span class="s">&quot;qadapters&quot;</span><span class="p">]:</span>
            <span class="n">d</span><span class="p">[</span><span class="s">&quot;queue&quot;</span><span class="p">][</span><span class="s">&quot;qtype&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;shell&quot;</span>
            <span class="n">d</span><span class="p">[</span><span class="s">&quot;limits&quot;</span><span class="p">][</span><span class="s">&quot;min_cores&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">mpi_procs</span>
            <span class="n">d</span><span class="p">[</span><span class="s">&quot;limits&quot;</span><span class="p">][</span><span class="s">&quot;max_cores&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">mpi_procs</span>

        <span class="c">#print(my_kwargs)</span>
        <span class="n">new</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="p">(</span><span class="o">**</span><span class="n">my_kwargs</span><span class="p">)</span>
        <span class="n">new</span><span class="o">.</span><span class="n">set_mpi_procs</span><span class="p">(</span><span class="n">mpi_procs</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">new</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">has_queue</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;True if we are submitting jobs via a queue manager.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">qadapter</span><span class="o">.</span><span class="n">QTYPE</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">!=</span> <span class="s">&quot;shell&quot;</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">qads</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;List of :class:`QueueAdapter` objects sorted according to priorities (highest comes first)&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_qads</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">qadapter</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The qadapter used to submit jobs.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_qads</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_qadpos</span><span class="p">]</span>

<div class="viewcode-block" id="TaskManager.select_qadapter"><a class="viewcode-back" href="../../../../pymatgen.io.abinit.html#pymatgen.io.abinit.tasks.TaskManager.select_qadapter">[docs]</a>    <span class="k">def</span> <span class="nf">select_qadapter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pconfs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Given a list of parallel configurations, pconfs, this method select an `optimal` configuration</span>
<span class="sd">        according to some criterion as well as the :class:`QueueAdapter` to use.</span>

<span class="sd">        Args:</span>
<span class="sd">            pconfs: :class:`ParalHints` object with the list of parallel configurations</span>

<span class="sd">        Returns:</span>
<span class="sd">            :class:`ParallelConf` object with the `optimal` configuration.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># Order the list of configurations according to policy.</span>
        <span class="n">policy</span><span class="p">,</span> <span class="n">max_ncpus</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">policy</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_cores</span>
        <span class="n">pconfs</span> <span class="o">=</span> <span class="n">pconfs</span><span class="o">.</span><span class="n">get_ordered_with_policy</span><span class="p">(</span><span class="n">policy</span><span class="p">,</span> <span class="n">max_ncpus</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">policy</span><span class="o">.</span><span class="n">precedence</span> <span class="o">==</span> <span class="s">&quot;qadapter&quot;</span><span class="p">:</span>

            <span class="c"># Try to run on the qadapter with the highest priority.</span>
            <span class="k">for</span> <span class="n">qadpos</span><span class="p">,</span> <span class="n">qad</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">qads</span><span class="p">):</span>
                <span class="n">possible_pconfs</span> <span class="o">=</span> <span class="p">[</span><span class="n">pc</span> <span class="k">for</span> <span class="n">pc</span> <span class="ow">in</span> <span class="n">pconfs</span> <span class="k">if</span> <span class="n">qad</span><span class="o">.</span><span class="n">can_run_pconf</span><span class="p">(</span><span class="n">pc</span><span class="p">)]</span> 

                <span class="k">if</span> <span class="n">qad</span><span class="o">.</span><span class="n">allocation</span> <span class="o">==</span> <span class="s">&quot;nodes&quot;</span><span class="p">:</span>
                    <span class="c"># Select the configuration divisible by nodes if possible.</span>
                    <span class="k">for</span> <span class="n">pconf</span> <span class="ow">in</span> <span class="n">possible_pconfs</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">pconf</span><span class="o">.</span><span class="n">num_cores</span> <span class="o">%</span> <span class="n">qad</span><span class="o">.</span><span class="n">hw</span><span class="o">.</span><span class="n">cores_per_node</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_use_qadpos_pconf</span><span class="p">(</span><span class="n">qadpos</span><span class="p">,</span> <span class="n">pconf</span><span class="p">)</span>
                
                <span class="c"># Here we select the first one.</span>
                <span class="k">if</span> <span class="n">possible_pconfs</span><span class="p">:</span>
                    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_use_qadpos_pconf</span><span class="p">(</span><span class="n">qadpos</span><span class="p">,</span> <span class="n">possible_pconfs</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

        <span class="k">elif</span> <span class="n">policy</span><span class="o">.</span><span class="n">precedence</span> <span class="o">==</span> <span class="s">&quot;autoparal_conf&quot;</span><span class="p">:</span>
            <span class="c"># Try to run on the first pconf irrespectively of the priority of the qadapter.</span>
            <span class="k">for</span> <span class="n">pconf</span> <span class="ow">in</span> <span class="n">pconfs</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">qadpos</span><span class="p">,</span> <span class="n">qad</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">qads</span><span class="p">):</span>

                    <span class="k">if</span> <span class="n">qad</span><span class="o">.</span><span class="n">allocation</span> <span class="o">==</span> <span class="s">&quot;nodes&quot;</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">pconf</span><span class="o">.</span><span class="n">num_cores</span> <span class="o">%</span> <span class="n">qad</span><span class="o">.</span><span class="n">hw</span><span class="o">.</span><span class="n">cores_per_node</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="k">continue</span> <span class="c"># Ignore it. not very clean</span>

                    <span class="k">if</span> <span class="n">qad</span><span class="o">.</span><span class="n">can_run_pconf</span><span class="p">(</span><span class="n">pconf</span><span class="p">):</span>
                        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_use_qadpos_pconf</span><span class="p">(</span><span class="n">qadpos</span><span class="p">,</span> <span class="n">pconf</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;Wrong value of policy.precedence = </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="n">policy</span><span class="o">.</span><span class="n">precedence</span><span class="p">)</span>

        <span class="c"># No qadapter could be found</span>
        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s">&quot;Cannot find qadapter for this run!&quot;</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_use_qadpos_pconf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">qadpos</span><span class="p">,</span> <span class="n">pconf</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function is called when we have accepted the :class:`ParalConf` pconf.</span>
<span class="sd">        Returns pconf</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_qadpos</span> <span class="o">=</span> <span class="n">qadpos</span> 

        <span class="c"># Change the number of MPI/OMP cores.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_mpi_procs</span><span class="p">(</span><span class="n">pconf</span><span class="o">.</span><span class="n">mpi_procs</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_omp</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">set_omp_threads</span><span class="p">(</span><span class="n">pconf</span><span class="o">.</span><span class="n">omp_threads</span><span class="p">)</span>
                                                                      
        <span class="c"># Set memory per proc.</span>
        <span class="c">#FIXME: Fixer may have changed the memory per proc and should not be resetted by ParalConf</span>
        <span class="c">#self.set_mem_per_proc(pconf.mem_per_proc)</span>
        <span class="k">return</span> <span class="n">pconf</span>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;String representation.&quot;&quot;&quot;</span>
        <span class="n">lines</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">app</span> <span class="o">=</span> <span class="n">lines</span><span class="o">.</span><span class="n">append</span>
        <span class="c">#app(&quot;[Task policy]\n%s&quot; % str(self.policy))</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">qad</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">qads</span><span class="p">):</span>
            <span class="n">app</span><span class="p">(</span><span class="s">&quot;[Qadapter </span><span class="si">%d</span><span class="s">]</span><span class="se">\n</span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">qad</span><span class="p">)))</span>
        <span class="n">app</span><span class="p">(</span><span class="s">&quot;Qadapter selected: </span><span class="si">%d</span><span class="s">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">_qadpos</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_db</span><span class="p">:</span>
            <span class="n">app</span><span class="p">(</span><span class="s">&quot;[MongoDB database]:&quot;</span><span class="p">)</span>
            <span class="n">app</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">db_connector</span><span class="p">))</span>

        <span class="k">return</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">lines</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">has_db</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;True if we are using MongoDB database&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">bool</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">db_connector</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">has_omp</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;True if we are using OpenMP parallelization.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">qadapter</span><span class="o">.</span><span class="n">has_omp</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">num_cores</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Total number of CPUs used to run the task.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">qadapter</span><span class="o">.</span><span class="n">num_cores</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">mpi_procs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Number of MPI processes.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">qadapter</span><span class="o">.</span><span class="n">mpi_procs</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">mem_per_proc</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Memory per MPI process.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">qadapter</span><span class="o">.</span><span class="n">mem_per_proc</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">omp_threads</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Number of OpenMP threads&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">qadapter</span><span class="o">.</span><span class="n">omp_threads</span>

<div class="viewcode-block" id="TaskManager.deepcopy"><a class="viewcode-back" href="../../../../pymatgen.io.abinit.html#pymatgen.io.abinit.tasks.TaskManager.deepcopy">[docs]</a>    <span class="k">def</span> <span class="nf">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Deep copy of self.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span></div>

<div class="viewcode-block" id="TaskManager.set_mpi_procs"><a class="viewcode-back" href="../../../../pymatgen.io.abinit.html#pymatgen.io.abinit.tasks.TaskManager.set_mpi_procs">[docs]</a>    <span class="k">def</span> <span class="nf">set_mpi_procs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mpi_procs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set the number of MPI nodes to use.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">qadapter</span><span class="o">.</span><span class="n">set_mpi_procs</span><span class="p">(</span><span class="n">mpi_procs</span><span class="p">)</span></div>

<div class="viewcode-block" id="TaskManager.set_omp_threads"><a class="viewcode-back" href="../../../../pymatgen.io.abinit.html#pymatgen.io.abinit.tasks.TaskManager.set_omp_threads">[docs]</a>    <span class="k">def</span> <span class="nf">set_omp_threads</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">omp_threads</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set the number of OpenMp threads to use.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">qadapter</span><span class="o">.</span><span class="n">set_omp_threads</span><span class="p">(</span><span class="n">omp_threads</span><span class="p">)</span></div>

<div class="viewcode-block" id="TaskManager.set_mem_per_proc"><a class="viewcode-back" href="../../../../pymatgen.io.abinit.html#pymatgen.io.abinit.tasks.TaskManager.set_mem_per_proc">[docs]</a>    <span class="k">def</span> <span class="nf">set_mem_per_proc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mem_mb</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set the memory (in Megabytes) per CPU.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">qadapter</span><span class="o">.</span><span class="n">set_mem_per_proc</span><span class="p">(</span><span class="n">mem_mb</span><span class="p">)</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">max_cores</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Maximum number of cores that can be used.</span>
<span class="sd">        This value is mainly used in the autoparal part to get the list of possible configurations.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">max</span><span class="p">(</span><span class="n">q</span><span class="o">.</span><span class="n">hint_cores</span> <span class="k">for</span> <span class="n">q</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">qads</span><span class="p">)</span>

<div class="viewcode-block" id="TaskManager.get_njobs_in_queue"><a class="viewcode-back" href="../../../../pymatgen.io.abinit.html#pymatgen.io.abinit.tasks.TaskManager.get_njobs_in_queue">[docs]</a>    <span class="k">def</span> <span class="nf">get_njobs_in_queue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">username</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        returns the number of jobs in the queue,</span>
<span class="sd">        returns None when the number of jobs cannot be determined.</span>

<span class="sd">        Args:</span>
<span class="sd">            username: (str) the username of the jobs to count (default is to autodetect)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">qadapter</span><span class="o">.</span><span class="n">get_njobs_in_queue</span><span class="p">(</span><span class="n">username</span><span class="o">=</span><span class="n">username</span><span class="p">)</span></div>

<div class="viewcode-block" id="TaskManager.cancel"><a class="viewcode-back" href="../../../../pymatgen.io.abinit.html#pymatgen.io.abinit.tasks.TaskManager.cancel">[docs]</a>    <span class="k">def</span> <span class="nf">cancel</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">job_id</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Cancel the job. Returns exit status.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">qadapter</span><span class="o">.</span><span class="n">cancel</span><span class="p">(</span><span class="n">job_id</span><span class="p">)</span></div>

<div class="viewcode-block" id="TaskManager.write_jobfile"><a class="viewcode-back" href="../../../../pymatgen.io.abinit.html#pymatgen.io.abinit.tasks.TaskManager.write_jobfile">[docs]</a>    <span class="k">def</span> <span class="nf">write_jobfile</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">task</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Write the submission script. Return the path of the script</span>

<span class="sd">        ================  ============================================</span>
<span class="sd">        kwargs            Meaning</span>
<span class="sd">        ================  ============================================</span>
<span class="sd">        exec_args         List of arguments passed to task.executable.</span>
<span class="sd">                          Default: no arguments.</span>

<span class="sd">        ================  ============================================</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">script</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">qadapter</span><span class="o">.</span><span class="n">get_script_str</span><span class="p">(</span>
            <span class="n">job_name</span><span class="o">=</span><span class="n">task</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> 
            <span class="n">launch_dir</span><span class="o">=</span><span class="n">task</span><span class="o">.</span><span class="n">workdir</span><span class="p">,</span>
            <span class="n">executable</span><span class="o">=</span><span class="n">task</span><span class="o">.</span><span class="n">executable</span><span class="p">,</span>
            <span class="n">qout_path</span><span class="o">=</span><span class="n">task</span><span class="o">.</span><span class="n">qout_file</span><span class="o">.</span><span class="n">path</span><span class="p">,</span>
            <span class="n">qerr_path</span><span class="o">=</span><span class="n">task</span><span class="o">.</span><span class="n">qerr_file</span><span class="o">.</span><span class="n">path</span><span class="p">,</span>
            <span class="n">stdin</span><span class="o">=</span><span class="n">task</span><span class="o">.</span><span class="n">files_file</span><span class="o">.</span><span class="n">path</span><span class="p">,</span> 
            <span class="n">stdout</span><span class="o">=</span><span class="n">task</span><span class="o">.</span><span class="n">log_file</span><span class="o">.</span><span class="n">path</span><span class="p">,</span>
            <span class="n">stderr</span><span class="o">=</span><span class="n">task</span><span class="o">.</span><span class="n">stderr_file</span><span class="o">.</span><span class="n">path</span><span class="p">,</span>
            <span class="n">exec_args</span><span class="o">=</span><span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s">&quot;exec_args&quot;</span><span class="p">,</span> <span class="p">[]),</span>
        <span class="p">)</span>

        <span class="c"># Write the script.</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">task</span><span class="o">.</span><span class="n">job_file</span><span class="o">.</span><span class="n">path</span><span class="p">,</span> <span class="s">&quot;w&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">fh</span><span class="p">:</span>
            <span class="n">fh</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">script</span><span class="p">)</span>
            <span class="n">task</span><span class="o">.</span><span class="n">job_file</span><span class="o">.</span><span class="n">chmod</span><span class="p">(</span><span class="mi">0</span><span class="n">o740</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">task</span><span class="o">.</span><span class="n">job_file</span><span class="o">.</span><span class="n">path</span></div>

<div class="viewcode-block" id="TaskManager.launch"><a class="viewcode-back" href="../../../../pymatgen.io.abinit.html#pymatgen.io.abinit.tasks.TaskManager.launch">[docs]</a>    <span class="k">def</span> <span class="nf">launch</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">task</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Build the input files and submit the task via the :class:`Qadapter` </span>

<span class="sd">        Args:</span>
<span class="sd">            task: :class:`TaskObject`</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">            Process object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">task</span><span class="o">.</span><span class="n">status</span> <span class="o">==</span> <span class="n">task</span><span class="o">.</span><span class="n">S_LOCKED</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;You shall not submit a locked task!&quot;</span><span class="p">)</span>

        <span class="c"># Build the task </span>
        <span class="n">task</span><span class="o">.</span><span class="n">build</span><span class="p">()</span>

        <span class="c"># Pass information on the time limit to Abinit (we always assume ndtset == 1)</span>
        <span class="k">if</span> <span class="bp">False</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">task</span><span class="p">,</span> <span class="n">AbinitTask</span><span class="p">):</span>
            <span class="n">args</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&quot;exec_args&quot;</span><span class="p">,</span> <span class="p">[])</span>
            <span class="k">if</span> <span class="n">args</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span> <span class="n">args</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">args</span> <span class="o">=</span> <span class="n">args</span><span class="p">[:]</span>
            <span class="n">args</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s">&quot;--timelimit </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="n">qu</span><span class="o">.</span><span class="n">time2slurm</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">qadapter</span><span class="o">.</span><span class="n">timelimit</span><span class="p">))</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s">&quot;exec_args&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">args</span>
            <span class="k">print</span><span class="p">(</span><span class="s">&quot;Will pass timelimit option to abinit </span><span class="si">%s</span><span class="s">:&quot;</span> <span class="o">%</span> <span class="n">args</span><span class="p">)</span>

        <span class="c"># Write the submission script</span>
        <span class="n">script_file</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">write_jobfile</span><span class="p">(</span><span class="n">task</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="c"># Submit the task and save the queue id.</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">qjob</span><span class="p">,</span> <span class="n">process</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">qadapter</span><span class="o">.</span><span class="n">submit_to_queue</span><span class="p">(</span><span class="n">script_file</span><span class="p">)</span>
            <span class="n">task</span><span class="o">.</span><span class="n">set_status</span><span class="p">(</span><span class="n">task</span><span class="o">.</span><span class="n">S_SUB</span><span class="p">,</span> <span class="n">msg</span><span class="o">=</span><span class="s">&#39;submitted to queue&#39;</span><span class="p">)</span>
            <span class="n">task</span><span class="o">.</span><span class="n">set_qjob</span><span class="p">(</span><span class="n">qjob</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">process</span>

        <span class="k">except</span> <span class="bp">self</span><span class="o">.</span><span class="n">qadapter</span><span class="o">.</span><span class="n">MaxNumLaunchesError</span> <span class="k">as</span> <span class="n">exc</span><span class="p">:</span>
            <span class="c"># TODO: Here we should try to switch to another qadapter</span>
            <span class="c"># 1) Find a new parallel configuration in those stored in task.pconfs</span>
            <span class="c"># 2) Change the input file.</span>
            <span class="c"># 3) Regenerate the submission script</span>
            <span class="c"># 4) Relaunch</span>
            <span class="n">task</span><span class="o">.</span><span class="n">set_status</span><span class="p">(</span><span class="n">task</span><span class="o">.</span><span class="n">S_ERROR</span><span class="p">,</span> <span class="n">msg</span><span class="o">=</span><span class="s">&quot;max_num_launches reached: </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="n">exc</span><span class="p">))</span>
            <span class="k">raise</span></div>

<div class="viewcode-block" id="TaskManager.get_collection"><a class="viewcode-back" href="../../../../pymatgen.io.abinit.html#pymatgen.io.abinit.tasks.TaskManager.get_collection">[docs]</a>    <span class="k">def</span> <span class="nf">get_collection</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the MongoDB collection used to store the results.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">db_connector</span><span class="o">.</span><span class="n">get_collection</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="TaskManager.increase_mem"><a class="viewcode-back" href="../../../../pymatgen.io.abinit.html#pymatgen.io.abinit.tasks.TaskManager.increase_mem">[docs]</a>    <span class="k">def</span> <span class="nf">increase_mem</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span></div>
        <span class="c"># OLD</span>
        <span class="c"># with GW calculations in mind with GW mem = 10,</span>
        <span class="c"># the response fuction is in memory and not distributed</span>
        <span class="c"># we need to increase memory if jobs fail ...</span>
        <span class="c"># return self.qadapter.more_mem_per_proc()</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">qadapter</span><span class="o">.</span><span class="n">more_mem_per_proc</span><span class="p">()</span>
        <span class="k">except</span> <span class="n">QueueAdapterError</span><span class="p">:</span>
            <span class="c"># here we should try to switch to an other qadapter</span>
            <span class="k">raise</span> <span class="n">ManagerIncreaseError</span><span class="p">(</span><span class="s">&#39;manager failed to increase mem&#39;</span><span class="p">)</span>

<div class="viewcode-block" id="TaskManager.increase_ncpus"><a class="viewcode-back" href="../../../../pymatgen.io.abinit.html#pymatgen.io.abinit.tasks.TaskManager.increase_ncpus">[docs]</a>    <span class="k">def</span> <span class="nf">increase_ncpus</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        increase the number of cpus, first ask the current quadapter, if that one raises a QadapterIncreaseError</span>
<span class="sd">        switch to the next qadapter. If all fail raise an ManagerIncreaseError</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">qadapter</span><span class="o">.</span><span class="n">more_cores</span><span class="p">()</span>
        <span class="k">except</span> <span class="n">QueueAdapterError</span><span class="p">:</span>
            <span class="c"># here we should try to switch to an other qadapter</span>
            <span class="k">raise</span> <span class="n">ManagerIncreaseError</span><span class="p">(</span><span class="s">&#39;manager failed to increase ncpu&#39;</span><span class="p">)</span></div>

<div class="viewcode-block" id="TaskManager.increase_resources"><a class="viewcode-back" href="../../../../pymatgen.io.abinit.html#pymatgen.io.abinit.tasks.TaskManager.increase_resources">[docs]</a>    <span class="k">def</span> <span class="nf">increase_resources</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">qadapter</span><span class="o">.</span><span class="n">more_cores</span><span class="p">()</span>
            <span class="k">return</span>
        <span class="k">except</span> <span class="n">QueueAdapterError</span><span class="p">:</span>
            <span class="k">pass</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">qadapter</span><span class="o">.</span><span class="n">more_mem_per_proc</span><span class="p">()</span>
        <span class="k">except</span> <span class="n">QueueAdapterError</span><span class="p">:</span>
            <span class="c"># here we should try to switch to an other qadapter</span>
            <span class="k">raise</span> <span class="n">ManagerIncreaseError</span><span class="p">(</span><span class="s">&#39;manager failed to increase resources&#39;</span><span class="p">)</span></div>

<div class="viewcode-block" id="TaskManager.exclude_nodes"><a class="viewcode-back" href="../../../../pymatgen.io.abinit.html#pymatgen.io.abinit.tasks.TaskManager.exclude_nodes">[docs]</a>    <span class="k">def</span> <span class="nf">exclude_nodes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nodes</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">qadapter</span><span class="o">.</span><span class="n">exclude_nodes</span><span class="p">(</span><span class="n">nodes</span><span class="o">=</span><span class="n">nodes</span><span class="p">)</span>
        <span class="k">except</span> <span class="n">QueueAdapterError</span><span class="p">:</span>
            <span class="c"># here we should try to switch to an other qadapter</span>
            <span class="k">raise</span> <span class="n">ManagerIncreaseError</span><span class="p">(</span><span class="s">&#39;manager failed to exclude nodes&#39;</span><span class="p">)</span></div>

<div class="viewcode-block" id="TaskManager.increase_time"><a class="viewcode-back" href="../../../../pymatgen.io.abinit.html#pymatgen.io.abinit.tasks.TaskManager.increase_time">[docs]</a>    <span class="k">def</span> <span class="nf">increase_time</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">qadapter</span><span class="o">.</span><span class="n">more_time</span><span class="p">()</span>
        <span class="k">except</span> <span class="n">QueueAdapterError</span><span class="p">:</span>
            <span class="c"># here we should try to switch to an other qadapter</span>
            <span class="k">raise</span> <span class="n">ManagerIncreaseError</span><span class="p">(</span><span class="s">&#39;manager failed to increase time&#39;</span><span class="p">)</span></div></div>


<span class="k">class</span> <span class="nc">FakeProcess</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This object is attached to a :class:`Task` instance if the task has not been submitted</span>
<span class="sd">    This trick allows us to simulate a process that is still running so that </span>
<span class="sd">    we can safely poll task.process.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">poll</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">None</span>

    <span class="k">def</span> <span class="nf">wait</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s">&quot;Cannot wait a FakeProcess&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">communicate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">input</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s">&quot;Cannot communicate with a FakeProcess&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">kill</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s">&quot;Cannot kill a FakeProcess&quot;</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">returncode</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">None</span>


<span class="k">class</span> <span class="nc">MyTimedelta</span><span class="p">(</span><span class="n">datetime</span><span class="o">.</span><span class="n">timedelta</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;A customized version of timedelta whose __str__ method doesn&#39;t print microseconds.&quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__new__</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">days</span><span class="p">,</span> <span class="n">seconds</span><span class="p">,</span> <span class="n">microseconds</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">datetime</span><span class="o">.</span><span class="n">timedelta</span><span class="o">.</span><span class="n">__new__</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">days</span><span class="p">,</span> <span class="n">seconds</span><span class="p">,</span> <span class="n">microseconds</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Remove microseconds from timedelta default __str__&quot;&quot;&quot;</span>
        <span class="n">s</span> <span class="o">=</span> <span class="nb">super</span><span class="p">(</span><span class="n">MyTimedelta</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__str__</span><span class="p">()</span>
        <span class="n">microsec</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s">&quot;.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">microsec</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span> <span class="n">s</span> <span class="o">=</span> <span class="n">s</span><span class="p">[:</span><span class="n">microsec</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">s</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">as_timedelta</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">delta</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Convert delta into a MyTimedelta object.&quot;&quot;&quot;</span>
        <span class="c"># Cannot monkey patch the __class__ and must pass through __new__ as the object is immutable.</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">delta</span><span class="p">,</span> <span class="n">cls</span><span class="p">):</span> <span class="k">return</span> <span class="n">delta</span>
        <span class="k">return</span> <span class="n">cls</span><span class="p">(</span><span class="n">delta</span><span class="o">.</span><span class="n">days</span><span class="p">,</span> <span class="n">delta</span><span class="o">.</span><span class="n">seconds</span><span class="p">,</span> <span class="n">delta</span><span class="o">.</span><span class="n">microseconds</span><span class="p">)</span> 


<span class="k">class</span> <span class="nc">TaskDateTimes</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Small object containing useful :class:`datetime.datatime` objects associated to important events.</span>

<span class="sd">    .. attributes:</span>

<span class="sd">        init: initialization datetime</span>
<span class="sd">        submission: submission datetime</span>
<span class="sd">        start: Begin of execution.</span>
<span class="sd">        end: End of execution.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">init</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">submission</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">start</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">end</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span> <span class="bp">None</span>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">lines</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">app</span> <span class="o">=</span> <span class="n">lines</span><span class="o">.</span><span class="n">append</span>

        <span class="n">app</span><span class="p">(</span><span class="s">&quot;Initialization done on: </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">init</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">submission</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span> <span class="n">app</span><span class="p">(</span><span class="s">&quot;Submitted on: </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">submission</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">start</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span> <span class="n">app</span><span class="p">(</span><span class="s">&quot;Started on: </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">start</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">end</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span> <span class="n">app</span><span class="p">(</span><span class="s">&quot;Completed on: </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">end</span><span class="p">)</span>

        <span class="k">return</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">lines</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_runtime</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;:class:`timedelta` with the run-time, None if the Task is not running&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">start</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span> <span class="k">return</span> <span class="bp">None</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">end</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">delta</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">start</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">delta</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">end</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">start</span>

        <span class="k">return</span> <span class="n">MyTimedelta</span><span class="o">.</span><span class="n">as_timedelta</span><span class="p">(</span><span class="n">delta</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_time_inqueue</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :class:`timedelta` with the time spent in the Queue, None if the Task is not running</span>

<span class="sd">        .. note:</span>
<span class="sd">            </span>
<span class="sd">            This value is always greater than the real value computed by the resource manager </span>
<span class="sd">            as we start to count only when check_status sets the `Task` status to S_RUN.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">submission</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span> <span class="k">return</span> <span class="bp">None</span>
        
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">start</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span> 
            <span class="n">delta</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">submission</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">delta</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">start</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">submission</span>
            <span class="c"># This happens when we read the exact start datetime from the ABINIT log file.</span>
            <span class="k">if</span> <span class="n">delta</span><span class="o">.</span><span class="n">total_seconds</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span> <span class="n">delta</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">timedelta</span><span class="p">(</span><span class="n">seconds</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">MyTimedelta</span><span class="o">.</span><span class="n">as_timedelta</span><span class="p">(</span><span class="n">delta</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">TaskError</span><span class="p">(</span><span class="n">NodeError</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Base Exception for :class:`Task` methods&quot;&quot;&quot;</span>
        

<span class="k">class</span> <span class="nc">TaskRestartError</span><span class="p">(</span><span class="n">TaskError</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Exception raised while trying to restart the :class:`Task`.&quot;&quot;&quot;</span>


<span class="k">class</span> <span class="nc">Task</span><span class="p">(</span><span class="n">six</span><span class="o">.</span><span class="n">with_metaclass</span><span class="p">(</span><span class="n">abc</span><span class="o">.</span><span class="n">ABCMeta</span><span class="p">,</span> <span class="n">Node</span><span class="p">)):</span>
    <span class="sd">&quot;&quot;&quot;A Task is a node that performs some kind of calculation.&quot;&quot;&quot;</span>
    <span class="c"># Use class attributes for TaskErrors so that we don&#39;t have to import them.</span>
    <span class="n">Error</span> <span class="o">=</span> <span class="n">TaskError</span>
    <span class="n">RestartError</span> <span class="o">=</span> <span class="n">TaskRestartError</span>

    <span class="c"># List of `AbinitEvent` subclasses that are tested in the check_status method. </span>
    <span class="c"># Subclasses should provide their own list if they need to check the converge status.</span>
    <span class="n">CRITICAL_EVENTS</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c"># Prefixes for Abinit (input, output, temporary) files.</span>
    <span class="n">Prefix</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">namedtuple</span><span class="p">(</span><span class="s">&quot;Prefix&quot;</span><span class="p">,</span> <span class="s">&quot;idata odata tdata&quot;</span><span class="p">)</span>
    <span class="n">pj</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span>

    <span class="n">prefix</span> <span class="o">=</span> <span class="n">Prefix</span><span class="p">(</span><span class="n">pj</span><span class="p">(</span><span class="s">&quot;indata&quot;</span><span class="p">,</span> <span class="s">&quot;in&quot;</span><span class="p">),</span> <span class="n">pj</span><span class="p">(</span><span class="s">&quot;outdata&quot;</span><span class="p">,</span> <span class="s">&quot;out&quot;</span><span class="p">),</span> <span class="n">pj</span><span class="p">(</span><span class="s">&quot;tmpdata&quot;</span><span class="p">,</span> <span class="s">&quot;tmp&quot;</span><span class="p">))</span>
    <span class="k">del</span> <span class="n">Prefix</span><span class="p">,</span> <span class="n">pj</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">input</span><span class="p">,</span> <span class="n">workdir</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">manager</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">deps</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Args:</span>
<span class="sd">            input: :class:`AbinitInput` object.</span>
<span class="sd">            workdir: Path to the working directory.</span>
<span class="sd">            manager: :class:`TaskManager` object.</span>
<span class="sd">            deps: Dictionary specifying the dependency of this node.</span>
<span class="sd">                  None means that this Task has no dependency.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># Init the node</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">Task</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_input</span> <span class="o">=</span> <span class="nb">input</span>

        <span class="k">if</span> <span class="n">workdir</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_workdir</span><span class="p">(</span><span class="n">workdir</span><span class="p">)</span>
                                                               
        <span class="k">if</span> <span class="n">manager</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_manager</span><span class="p">(</span><span class="n">manager</span><span class="p">)</span>

        <span class="c"># Handle possible dependencies.</span>
        <span class="k">if</span> <span class="n">deps</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add_deps</span><span class="p">(</span><span class="n">deps</span><span class="p">)</span>

        <span class="c"># Date-time associated to submission, start and end.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">datetimes</span> <span class="o">=</span> <span class="n">TaskDateTimes</span><span class="p">()</span>

        <span class="c"># Count the number of restarts.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_restarts</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_qjob</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">queue_errors</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">abi_errors</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c"># two flags that provide, dynamically, information on the scaling behavious of a task. If any process of fixing</span>
        <span class="c"># finds none scaling behaviour, they should be switched. If a task type is clearly not scaling they should be</span>
        <span class="c"># swiched.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mem_scales</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">load_scales</span> <span class="o">=</span> <span class="bp">True</span>

    <span class="k">def</span> <span class="nf">__getstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return state is pickled as the contents for the instance.</span>
<span class="sd">                                                                                      </span>
<span class="sd">        In this case we just remove the process since Subprocess objects cannot be pickled.</span>
<span class="sd">        This is the reason why we have to store the returncode in self._returncode instead</span>
<span class="sd">        of using self.process.returncode.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__dict__</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">k</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s">&quot;_process&quot;</span><span class="p">]}</span>

    <span class="c">#@check_spectator</span>
    <span class="k">def</span> <span class="nf">set_workdir</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">workdir</span><span class="p">,</span> <span class="n">chroot</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set the working directory. Cannot be set more than once unless chroot is True&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">chroot</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s">&quot;workdir&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">workdir</span> <span class="o">!=</span> <span class="n">workdir</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;self.workdir != workdir: </span><span class="si">%s</span><span class="s">, </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">workdir</span><span class="p">,</span>  <span class="n">workdir</span><span class="p">))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">workdir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">abspath</span><span class="p">(</span><span class="n">workdir</span><span class="p">)</span>

        <span class="c"># Files required for the execution.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">input_file</span> <span class="o">=</span> <span class="n">File</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">workdir</span><span class="p">,</span> <span class="s">&quot;run.abi&quot;</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">output_file</span> <span class="o">=</span> <span class="n">File</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">workdir</span><span class="p">,</span> <span class="s">&quot;run.abo&quot;</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">files_file</span> <span class="o">=</span> <span class="n">File</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">workdir</span><span class="p">,</span> <span class="s">&quot;run.files&quot;</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">job_file</span> <span class="o">=</span> <span class="n">File</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">workdir</span><span class="p">,</span> <span class="s">&quot;job.sh&quot;</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log_file</span> <span class="o">=</span> <span class="n">File</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">workdir</span><span class="p">,</span> <span class="s">&quot;run.log&quot;</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stderr_file</span> <span class="o">=</span> <span class="n">File</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">workdir</span><span class="p">,</span> <span class="s">&quot;run.err&quot;</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">start_lockfile</span> <span class="o">=</span> <span class="n">File</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">workdir</span><span class="p">,</span> <span class="s">&quot;__startlock__&quot;</span><span class="p">))</span>
        <span class="c"># This file is produce by Abinit if nprocs &gt; 1 and MPI_ABORT.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mpiabort_file</span> <span class="o">=</span> <span class="n">File</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">workdir</span><span class="p">,</span> <span class="s">&quot;__ABI_MPIABORTFILE__&quot;</span><span class="p">))</span>

        <span class="c"># Directories with input|output|temporary data.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">indir</span> <span class="o">=</span> <span class="n">Directory</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">workdir</span><span class="p">,</span> <span class="s">&quot;indata&quot;</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">outdir</span> <span class="o">=</span> <span class="n">Directory</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">workdir</span><span class="p">,</span> <span class="s">&quot;outdata&quot;</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tmpdir</span> <span class="o">=</span> <span class="n">Directory</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">workdir</span><span class="p">,</span> <span class="s">&quot;tmpdata&quot;</span><span class="p">))</span>

        <span class="c"># stderr and output file of the queue manager. Note extensions.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">qerr_file</span> <span class="o">=</span> <span class="n">File</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">workdir</span><span class="p">,</span> <span class="s">&quot;queue.qerr&quot;</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">qout_file</span> <span class="o">=</span> <span class="n">File</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">workdir</span><span class="p">,</span> <span class="s">&quot;queue.qout&quot;</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">set_manager</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">manager</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set the :class:`TaskManager` used to launch the Task.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">manager</span> <span class="o">=</span> <span class="n">manager</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">()</span>

    <span class="c">#@property</span>
    <span class="c">#def manager(self):</span>
    <span class="c">#    &quot;&quot;&quot;:class:`TaskManager` use to launch the Task. None if not set&quot;&quot;&quot;</span>
    <span class="c">#    try:</span>
    <span class="c">#        return self._manager</span>
    <span class="c">#    except AttributeError:</span>
    <span class="c">#        return None</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">work</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The :class:`Work` containing this `Task`.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_work</span>

    <span class="k">def</span> <span class="nf">set_work</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">work</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set the :class:`Work` associated to this `Task`.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s">&quot;_work&quot;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_work</span> <span class="o">=</span> <span class="n">work</span>
        <span class="k">else</span><span class="p">:</span> 
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_work</span> <span class="o">!=</span> <span class="n">work</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;self._work != work&quot;</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">flow</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The :class:`Flow` containing this `Task`.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">work</span><span class="o">.</span><span class="n">flow</span>

    <span class="nd">@lazy_property</span>
    <span class="k">def</span> <span class="nf">pos</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The position of the task in the :class:`Flow`&quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">task</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">work</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span> <span class="o">==</span> <span class="n">task</span><span class="p">:</span> 
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">work</span><span class="o">.</span><span class="n">pos</span><span class="p">,</span> <span class="n">i</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;Cannot find the position of </span><span class="si">%s</span><span class="s"> in flow </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">flow</span><span class="p">))</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">pos_str</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;String representation of self.pos&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="s">&quot;w&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">+</span> <span class="s">&quot;_t&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">num_launches</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Number of launches performed. This number includes both possible ABINIT restarts</span>
<span class="sd">        as well as possible launches done due to errors encountered with the resource manager</span>
<span class="sd">        or the hardware/software.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="n">q</span><span class="o">.</span><span class="n">num_launches</span> <span class="k">for</span> <span class="n">q</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">manager</span><span class="o">.</span><span class="n">qads</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">input</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;AbinitInput&quot; object.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_input</span>

    <span class="k">def</span> <span class="nf">get_inpvar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">varname</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the value of the ABINIT variable varname, None if not present.&quot;&quot;&quot;</span> 
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">input</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">varname</span><span class="p">,</span> <span class="n">default</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_set_inpvars</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the values of the ABINIT variables in the input file. Return dict with old values.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">kwargs</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="nb">dict</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">))</span>
        <span class="n">old_values</span> <span class="o">=</span> <span class="p">{</span><span class="n">vname</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">input</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">vname</span><span class="p">)</span> <span class="k">for</span> <span class="n">vname</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">input</span><span class="o">.</span><span class="n">set_vars</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">history</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s">&quot;Setting input variables: </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="n">kwargs</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">history</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s">&quot;Old values: </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="n">old_values</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">old_values</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">initial_structure</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initial structure of the task.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">input</span><span class="o">.</span><span class="n">structure</span>

    <span class="k">def</span> <span class="nf">make_input</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">with_header</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Construct the input file of the calculation.&quot;&quot;&quot;</span>
        <span class="n">s</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">input</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">with_header</span><span class="p">:</span> <span class="n">s</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">+</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span> <span class="o">+</span> <span class="n">s</span>
        <span class="k">return</span> <span class="n">s</span>

    <span class="k">def</span> <span class="nf">ipath_from_ext</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ext</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the path of the input file with extension ext.</span>
<span class="sd">        Use it when the file does not exist yet.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">workdir</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">prefix</span><span class="o">.</span><span class="n">idata</span> <span class="o">+</span> <span class="s">&quot;_&quot;</span> <span class="o">+</span> <span class="n">ext</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">opath_from_ext</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ext</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the path of the output file with extension ext.</span>
<span class="sd">        Use it when the file does not exist yet.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">workdir</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">prefix</span><span class="o">.</span><span class="n">odata</span> <span class="o">+</span> <span class="s">&quot;_&quot;</span> <span class="o">+</span> <span class="n">ext</span><span class="p">)</span>

    <span class="nd">@abc.abstractproperty</span>
    <span class="k">def</span> <span class="nf">executable</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Path to the executable associated to the task (internally stored in self._executable).</span>
<span class="sd">        &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">set_executable</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">executable</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set the executable associate to this task.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_executable</span> <span class="o">=</span> <span class="n">executable</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">process</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_process</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="c"># Attach a fake process so that we can poll it.</span>
            <span class="k">return</span> <span class="n">FakeProcess</span><span class="p">()</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">is_completed</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;True if the task has been executed.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">status</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">S_DONE</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">can_run</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The task can run if its status is &lt; S_SUB and all the other dependencies (if any) are done!&quot;&quot;&quot;</span>
        <span class="n">all_ok</span> <span class="o">=</span> <span class="nb">all</span><span class="p">([</span><span class="n">stat</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">S_OK</span> <span class="k">for</span> <span class="n">stat</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">deps_status</span><span class="p">])</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">status</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">S_SUB</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">status</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">S_LOCKED</span> <span class="ow">and</span> <span class="n">all_ok</span>

    <span class="c">#@check_spectator</span>
    <span class="k">def</span> <span class="nf">cancel</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Cancel the job. Returns 1 if job was cancelled.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">queue_id</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span> <span class="k">return</span> <span class="mi">0</span> 
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">status</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">S_DONE</span><span class="p">:</span> <span class="k">return</span> <span class="mi">0</span> 

        <span class="n">exit_status</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">manager</span><span class="o">.</span><span class="n">cancel</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">queue_id</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">exit_status</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span> 
            <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s">&quot;manager.cancel returned exit_status: </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="n">exit_status</span><span class="p">)</span>
            <span class="k">return</span> <span class="mi">0</span>

        <span class="c"># Remove output files and reset the status.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">history</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s">&quot;Job </span><span class="si">%s</span><span class="s"> cancelled by user&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">queue_id</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reset</span><span class="p">()</span>
        <span class="k">return</span> <span class="mi">1</span>

    <span class="c">#@check_spectator </span>
    <span class="k">def</span> <span class="nf">_on_done</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fix_ofiles</span><span class="p">()</span>

    <span class="c">#@check_spectator </span>
    <span class="k">def</span> <span class="nf">_on_ok</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c"># Fix output file names.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fix_ofiles</span><span class="p">()</span>

        <span class="c"># Get results</span>
        <span class="n">results</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">on_ok</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">finalized</span> <span class="o">=</span> <span class="bp">True</span>

        <span class="k">return</span> <span class="n">results</span>

    <span class="c">#@check_spectator</span>
    <span class="k">def</span> <span class="nf">on_ok</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method is called once the `Task` has reached status S_OK. </span>
<span class="sd">        Subclasses should provide their own implementation</span>

<span class="sd">        Returns:</span>
<span class="sd">            Dictionary that must contain at least the following entries:</span>
<span class="sd">                returncode:</span>
<span class="sd">                    0 on success. </span>
<span class="sd">                message: </span>
<span class="sd">                    a string that should provide a human-readable description of what has been performed.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">dict</span><span class="p">(</span><span class="n">returncode</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">message</span><span class="o">=</span><span class="s">&quot;Calling on_all_ok of the base class!&quot;</span><span class="p">)</span>

    <span class="c">#@check_spectator</span>
    <span class="k">def</span> <span class="nf">fix_ofiles</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method is called when the task reaches S_OK.</span>
<span class="sd">        It changes the extension of particular output files</span>
<span class="sd">        produced by Abinit so that the &#39;official&#39; extension</span>
<span class="sd">        is preserved e.g. out_1WF14 --&gt; out_1WF</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">filepaths</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">outdir</span><span class="o">.</span><span class="n">list_filepaths</span><span class="p">()</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s">&quot;in fix_ofiles with filepaths </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="nb">list</span><span class="p">(</span><span class="n">filepaths</span><span class="p">))</span>

        <span class="n">old2new</span> <span class="o">=</span> <span class="n">FilepathFixer</span><span class="p">()</span><span class="o">.</span><span class="n">fix_paths</span><span class="p">(</span><span class="n">filepaths</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">old</span><span class="p">,</span> <span class="n">new</span> <span class="ow">in</span> <span class="n">old2new</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">history</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s">&quot;will rename old </span><span class="si">%s</span><span class="s"> to new </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">old</span><span class="p">,</span> <span class="n">new</span><span class="p">))</span>
            <span class="n">os</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">old</span><span class="p">,</span> <span class="n">new</span><span class="p">)</span>

    <span class="c">#@check_spectator</span>
    <span class="k">def</span> <span class="nf">_restart</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">submit</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Called by restart once we have finished preparing the task for restarting.</span>

<span class="sd">        Return: </span>
<span class="sd">            True if task has been restarted</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_status</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">S_READY</span><span class="p">,</span> <span class="n">msg</span><span class="o">=</span><span class="s">&quot;Restarted on </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="n">time</span><span class="o">.</span><span class="n">asctime</span><span class="p">())</span>

        <span class="c"># Increase the counter.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_restarts</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">history</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s">&quot;Restarted, num_restarts </span><span class="si">%d</span><span class="s">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_restarts</span><span class="p">)</span>

        <span class="c"># Reset datetimes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">datetimes</span> <span class="o">=</span> <span class="n">TaskDateTimes</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">submit</span><span class="p">:</span>
            <span class="c"># Remove the lock file</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">start_lockfile</span><span class="o">.</span><span class="n">remove</span><span class="p">()</span>
            <span class="c"># Relaunch the task.</span>
            <span class="n">fired</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">fired</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">history</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s">&quot;Restart failed&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">fired</span> <span class="o">=</span> <span class="bp">False</span>

        <span class="k">return</span> <span class="n">fired</span>

    <span class="c">#@check_spectator</span>
    <span class="k">def</span> <span class="nf">restart</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Restart the calculation.  Subclasses should provide a concrete version that </span>
<span class="sd">        performs all the actions needed for preparing the restart and then calls self._restart</span>
<span class="sd">        to restart the task. The default implementation is empty.</span>

<span class="sd">        Returns:</span>
<span class="sd">            1 if job was restarted, 0 otherwise.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s">&quot;Calling the **empty** restart method of the base class&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="mi">0</span>

    <span class="k">def</span> <span class="nf">poll</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Check if child process has terminated. Set and return returncode attribute.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_returncode</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">poll</span><span class="p">()</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_returncode</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_status</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">S_DONE</span><span class="p">,</span> <span class="s">&quot;status set to Done&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_returncode</span>

    <span class="k">def</span> <span class="nf">wait</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Wait for child process to terminate. Set and return returncode attribute.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_returncode</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">wait</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_status</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">S_DONE</span><span class="p">,</span> <span class="s">&quot;status set to Done&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_returncode</span>

    <span class="k">def</span> <span class="nf">communicate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">input</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Interact with process: Send data to stdin. Read data from stdout and stderr, until end-of-file is reached. </span>
<span class="sd">        Wait for process to terminate. The optional input argument should be a string to be sent to the </span>
<span class="sd">        child process, or None, if no data should be sent to the child.</span>

<span class="sd">        communicate() returns a tuple (stdoutdata, stderrdata).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">stdoutdata</span><span class="p">,</span> <span class="n">stderrdata</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">communicate</span><span class="p">(</span><span class="nb">input</span><span class="o">=</span><span class="nb">input</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_returncode</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">returncode</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_status</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">S_DONE</span><span class="p">,</span> <span class="s">&quot;status set to Done&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">stdoutdata</span><span class="p">,</span> <span class="n">stderrdata</span> 

    <span class="k">def</span> <span class="nf">kill</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Kill the child.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">kill</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_status</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">S_ERROR</span><span class="p">,</span> <span class="s">&quot;status set to Error by task.kill&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_returncode</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">returncode</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">returncode</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The child return code, set by poll() and wait() (and indirectly by communicate()). </span>
<span class="sd">        A None value indicates that the process hasn&#39;t terminated yet.</span>
<span class="sd">        A negative value -N indicates that the child was terminated by signal N (Unix only).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span> 
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_returncode</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span>

    <span class="k">def</span> <span class="nf">reset</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Reset the task status. Mainly used if we made a silly mistake in the initial</span>
<span class="sd">        setup of the queue manager and we want to fix it and rerun the task.</span>

<span class="sd">        Returns:</span>
<span class="sd">            0 on success, 1 if reset failed.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># Can only reset tasks that are done.</span>
        <span class="c"># One should be able to reset &#39;Submitted&#39; tasks (sometimes, they are not in the queue</span>
        <span class="c">#   and we want to restart them)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">status</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">S_SUB</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">status</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">S_DONE</span><span class="p">:</span> <span class="k">return</span> <span class="mi">1</span>

        <span class="c"># Remove output files otherwise the EventParser will think the job is still running</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">output_file</span><span class="o">.</span><span class="n">remove</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log_file</span><span class="o">.</span><span class="n">remove</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stderr_file</span><span class="o">.</span><span class="n">remove</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">start_lockfile</span><span class="o">.</span><span class="n">remove</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">qerr_file</span><span class="o">.</span><span class="n">remove</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">qout_file</span><span class="o">.</span><span class="n">remove</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">set_status</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">S_INIT</span><span class="p">,</span> <span class="n">msg</span><span class="o">=</span><span class="s">&quot;Reset on </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="n">time</span><span class="o">.</span><span class="n">asctime</span><span class="p">())</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_qjob</span><span class="p">(</span><span class="bp">None</span><span class="p">)</span>

        <span class="k">return</span> <span class="mi">0</span>

    <span class="nd">@property</span>
    <span class="nd">@return_none_if_raise</span><span class="p">(</span><span class="ne">AttributeError</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">queue_id</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Queue identifier returned by the Queue manager. None if not set&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">qjob</span><span class="o">.</span><span class="n">qid</span>

    <span class="nd">@property</span>
    <span class="nd">@return_none_if_raise</span><span class="p">(</span><span class="ne">AttributeError</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">qname</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Queue name identifier returned by the Queue manager. None if not set&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">qjob</span><span class="o">.</span><span class="n">qname</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">qjob</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_qjob</span>

    <span class="k">def</span> <span class="nf">set_qjob</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">qjob</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set info on queue after submission.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_qjob</span> <span class="o">=</span> <span class="n">qjob</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">has_queue</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;True if we are submitting jobs via a queue manager.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">manager</span><span class="o">.</span><span class="n">qadapter</span><span class="o">.</span><span class="n">QTYPE</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">!=</span> <span class="s">&quot;shell&quot;</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">num_cores</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Total number of CPUs used to run the task.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">manager</span><span class="o">.</span><span class="n">num_cores</span>
                                                         
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">mpi_procs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Number of CPUs used for MPI.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">manager</span><span class="o">.</span><span class="n">mpi_procs</span>
                                                         
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">omp_threads</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Number of CPUs used for OpenMP.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">manager</span><span class="o">.</span><span class="n">omp_threads</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">mem_per_proc</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Memory per MPI process.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Memory</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">manager</span><span class="o">.</span><span class="n">mem_per_proc</span><span class="p">,</span> <span class="s">&quot;Mb&quot;</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">status</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Gives the status of the task.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_status</span>

    <span class="k">def</span> <span class="nf">lock</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">source_node</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Lock the task, source is the :class:`Node` that applies the lock.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">status</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">S_INIT</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;Trying to lock a task with status </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">status</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_status</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">S_LOCKED</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">history</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s">&quot;Locked by node </span><span class="si">%s</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">source_node</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">unlock</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">source_node</span><span class="p">,</span> <span class="n">check_status</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Unlock the task, set its status to `S_READY` so that the scheduler can submit it.</span>
<span class="sd">        source_node is the :class:`Node` that removed the lock</span>
<span class="sd">        Call task.check_status if check_status is True.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">status</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">S_LOCKED</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s">&quot;Trying to unlock a task with status </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">status</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_status</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">S_READY</span>
        <span class="k">if</span> <span class="n">check_status</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">check_status</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">history</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s">&quot;Unlocked by </span><span class="si">%s</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">source_node</span><span class="p">)</span>

    <span class="c">#@check_spectator</span>
    <span class="k">def</span> <span class="nf">set_status</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">status</span><span class="p">,</span> <span class="n">msg</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set and return the status of the task.</span>

<span class="sd">        Args:</span>
<span class="sd">            status: Status object or string representation of the status</span>
<span class="sd">            msg: string with human-readable message used in the case of errors.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># msg = &quot;No message provided&quot; if msg is None else msg</span>
        <span class="c"># lets refuse to accept changes in the status the do not have a message</span>
        
        <span class="c"># truncate strig if it&#39;s long. msg will be logged in the object and we don&#39;t want</span>
        <span class="c"># to waste memory.</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">2000</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="n">msg</span><span class="p">[:</span><span class="mi">2000</span><span class="p">]</span>
            <span class="n">msg</span> <span class="o">+=</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">... snip ...</span><span class="se">\n</span><span class="s">&quot;</span>

        <span class="c"># Locked files must be explicitly unlocked </span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">status</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">S_LOCKED</span> <span class="ow">or</span> <span class="n">status</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">S_LOCKED</span><span class="p">:</span>
            <span class="n">err_msg</span> <span class="o">=</span> <span class="p">(</span>
                 <span class="s">&quot;Locked files must be explicitly unlocked before calling set_status but</span><span class="se">\n</span><span class="s">&quot;</span>
                 <span class="s">&quot;task.status = </span><span class="si">%s</span><span class="s">, input status = </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">status</span><span class="p">,</span> <span class="n">status</span><span class="p">))</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="n">err_msg</span><span class="p">)</span>

        <span class="n">status</span> <span class="o">=</span> <span class="n">Status</span><span class="o">.</span><span class="n">as_status</span><span class="p">(</span><span class="n">status</span><span class="p">)</span>

        <span class="n">changed</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s">&quot;_status&quot;</span><span class="p">):</span>
            <span class="n">changed</span> <span class="o">=</span> <span class="p">(</span><span class="n">status</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_status</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_status</span> <span class="o">=</span> <span class="n">status</span>

        <span class="k">if</span> <span class="n">status</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">S_RUN</span><span class="p">:</span>
            <span class="c"># Set datetimes.start when the task enters S_RUN</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">datetimes</span><span class="o">.</span><span class="n">start</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">datetimes</span><span class="o">.</span><span class="n">start</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span>

        <span class="c"># Add new entry to history only if the status has changed.</span>
        <span class="k">if</span> <span class="n">changed</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">status</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">S_SUB</span><span class="p">:</span> 
                <span class="bp">self</span><span class="o">.</span><span class="n">datetimes</span><span class="o">.</span><span class="n">submission</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">history</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s">&quot;Submitted with MPI=</span><span class="si">%s</span><span class="s">, Omp=</span><span class="si">%s</span><span class="s">, Memproc=</span><span class="si">%.1f</span><span class="s"> [Gb] </span><span class="si">%s</span><span class="s"> &quot;</span> <span class="o">%</span> <span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">mpi_procs</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">omp_threads</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">mem_per_proc</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="s">&quot;Gb&quot;</span><span class="p">),</span> <span class="n">msg</span><span class="p">))</span>

            <span class="k">elif</span> <span class="n">status</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">S_OK</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">history</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s">&quot;Task completed </span><span class="si">%s</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">msg</span><span class="p">)</span>

            <span class="k">elif</span> <span class="n">status</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">S_ABICRITICAL</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">history</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s">&quot;Status set to S_ABI_CRITICAL due to: </span><span class="si">%s</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">msg</span><span class="p">)</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">history</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s">&quot;Status changed to </span><span class="si">%s</span><span class="s">. msg: </span><span class="si">%s</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">status</span><span class="p">,</span> <span class="n">msg</span><span class="p">)</span>

        <span class="c">#######################################################</span>
        <span class="c"># The section belows contains callbacks that should not</span>
        <span class="c"># be executed if we are in spectator_mode</span>
        <span class="c">#######################################################</span>
        <span class="k">if</span> <span class="n">status</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">S_DONE</span><span class="p">:</span>
            <span class="c"># Execute the callback</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_on_done</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">status</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">S_OK</span><span class="p">:</span>
            <span class="c"># Finalize the task.</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">finalized</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_on_ok</span><span class="p">()</span>

                <span class="c"># here we remove the output files of the task and of its parents.</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">gc</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">gc</span><span class="o">.</span><span class="n">policy</span> <span class="o">==</span> <span class="s">&quot;task&quot;</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">clean_output_files</span><span class="p">()</span>
           
            <span class="bp">self</span><span class="o">.</span><span class="n">send_signal</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">S_OK</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">status</span>

    <span class="k">def</span> <span class="nf">check_status</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function checks the status of the task by inspecting the output and the</span>
<span class="sd">        error files produced by the application and by the queue manager.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># 1) see it the job is blocked</span>
        <span class="c"># 2) see if an error occured at submitting the job the job was submitted, TODO these problems can be solved</span>
        <span class="c"># 3) see if there is output</span>
        <span class="c"># 4) see if abinit reports problems</span>
        <span class="c"># 5) see if both err files exist and are empty</span>
        <span class="c"># 6) no output and no err files, the job must still be running</span>
        <span class="c"># 7) try to find out what caused the problems</span>
        <span class="c"># 8) there is a problem but we did not figure out what ...</span>
        <span class="c"># 9) the only way of landing here is if there is a output file but no err files...</span>

        <span class="c"># 1) A locked task can only be unlocked by calling set_status explicitly.</span>
        <span class="c"># an errored task, should not end up here but just to be sure</span>
        <span class="n">black_list</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">S_LOCKED</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">S_ERROR</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">status</span> <span class="ow">in</span> <span class="n">black_list</span><span class="p">:</span> <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">status</span>

        <span class="c"># 2) Check the returncode of the process (the process of submitting the job) first.</span>
        <span class="c"># this point type of problem should also be handled by the scheduler error parser</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">returncode</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c"># The job was not submitted properly</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">set_status</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">S_QCRITICAL</span><span class="p">,</span> <span class="n">msg</span><span class="o">=</span><span class="s">&quot;return code </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">returncode</span><span class="p">)</span>

        <span class="c"># If we have an abort file produced by Abinit</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mpiabort_file</span><span class="o">.</span><span class="n">exists</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">set_status</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">S_ABICRITICAL</span><span class="p">,</span> <span class="n">msg</span><span class="o">=</span><span class="s">&quot;Found ABINIT abort file&quot;</span><span class="p">)</span>

        <span class="c"># Analyze the stderr file for Fortran runtime errors.</span>
        <span class="n">err_msg</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">stderr_file</span><span class="o">.</span><span class="n">exists</span><span class="p">:</span>
            <span class="n">err_msg</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stderr_file</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>

        <span class="c"># Analyze the stderr file of the resource manager runtime errors.</span>
        <span class="n">qerr_info</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">qerr_file</span><span class="o">.</span><span class="n">exists</span><span class="p">:</span>
            <span class="n">qerr_info</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">qerr_file</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>

        <span class="c"># Analyze the stdout file of the resource manager (needed for PBS !)</span>
        <span class="n">qout_info</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">qout_file</span><span class="o">.</span><span class="n">exists</span><span class="p">:</span>
            <span class="n">qout_info</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">qout_file</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>

        <span class="c"># Start to check ABINIT status if the output file has been created.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_file</span><span class="o">.</span><span class="n">exists</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">report</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_event_report</span><span class="p">()</span>
            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">exc</span><span class="p">:</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="s">&quot;</span><span class="si">%s</span><span class="s"> exception while parsing event_report:</span><span class="se">\n</span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">exc</span><span class="p">)</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">set_status</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">S_ABICRITICAL</span><span class="p">,</span> <span class="n">msg</span><span class="o">=</span><span class="n">msg</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">report</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">set_status</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">S_ERROR</span><span class="p">,</span> <span class="n">msg</span><span class="o">=</span><span class="s">&quot;got None report!&quot;</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">report</span><span class="o">.</span><span class="n">run_completed</span><span class="p">:</span>
                <span class="c"># Here we  set the correct timing data reported by Abinit</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">datetimes</span><span class="o">.</span><span class="n">start</span> <span class="o">=</span> <span class="n">report</span><span class="o">.</span><span class="n">start_datetime</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">datetimes</span><span class="o">.</span><span class="n">end</span> <span class="o">=</span> <span class="n">report</span><span class="o">.</span><span class="n">end_datetime</span>

                <span class="c"># Check if the calculation converged.</span>
                <span class="n">not_ok</span> <span class="o">=</span> <span class="n">report</span><span class="o">.</span><span class="n">filter_types</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">CRITICAL_EVENTS</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">not_ok</span><span class="p">:</span>
                    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">set_status</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">S_UNCONVERGED</span><span class="p">,</span> <span class="n">msg</span><span class="o">=</span><span class="s">&#39;status set to unconverged based on abiout&#39;</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">set_status</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">S_OK</span><span class="p">,</span> <span class="n">msg</span><span class="o">=</span><span class="s">&quot;status set to ok based on abiout&quot;</span><span class="p">)</span>

            <span class="c"># Calculation still running or errors?</span>
            <span class="k">if</span> <span class="n">report</span><span class="o">.</span><span class="n">errors</span><span class="p">:</span>
                <span class="c"># Abinit reported problems</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s">&#39;Found errors in report&#39;</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">error</span> <span class="ow">in</span> <span class="n">report</span><span class="o">.</span><span class="n">errors</span><span class="p">:</span>
                    <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">error</span><span class="p">))</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">abi_errors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">error</span><span class="p">)</span>
                    <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">abi_errors</span> <span class="o">=</span> <span class="p">[</span><span class="n">error</span><span class="p">]</span>

                <span class="c"># The job is unfixable due to ABINIT errors</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s">&quot;</span><span class="si">%s</span><span class="s">: Found Errors or Bugs in ABINIT main output!&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="p">)</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">repr</span><span class="p">,</span> <span class="n">report</span><span class="o">.</span><span class="n">errors</span><span class="p">))</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">set_status</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">S_ABICRITICAL</span><span class="p">,</span> <span class="n">msg</span><span class="o">=</span><span class="n">msg</span><span class="p">)</span>

            <span class="c"># 5)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">stderr_file</span><span class="o">.</span><span class="n">exists</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">err_msg</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">qerr_file</span><span class="o">.</span><span class="n">exists</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">qerr_info</span><span class="p">:</span>
                    <span class="c"># there is output and no errors</span>
                    <span class="c"># The job still seems to be running</span>
                    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">set_status</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">S_RUN</span><span class="p">,</span> <span class="n">msg</span><span class="o">=</span><span class="s">&#39;there is output and no errors: job still seems to be running&#39;</span><span class="p">)</span>

        <span class="c"># 6)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_file</span><span class="o">.</span><span class="n">exists</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s">&quot;output_file does not exists&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">stderr_file</span><span class="o">.</span><span class="n">exists</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">qerr_file</span><span class="o">.</span><span class="n">exists</span><span class="p">:</span>     
                <span class="c"># No output at allThe job is still in the queue.</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">status</span>
                
        <span class="c"># 7) Analyze the files of the resource manager and abinit and execution err (mvs)</span>
        <span class="k">if</span> <span class="n">qerr_info</span> <span class="ow">or</span> <span class="n">qout_info</span><span class="p">:</span>
            <span class="kn">from</span> <span class="nn">pymatgen.io.abinit.scheduler_error_parsers</span> <span class="kn">import</span> <span class="n">get_parser</span>
            <span class="n">scheduler_parser</span> <span class="o">=</span> <span class="n">get_parser</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">manager</span><span class="o">.</span><span class="n">qadapter</span><span class="o">.</span><span class="n">QTYPE</span><span class="p">,</span> <span class="n">err_file</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">qerr_file</span><span class="o">.</span><span class="n">path</span><span class="p">,</span>
                                          <span class="n">out_file</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">qout_file</span><span class="o">.</span><span class="n">path</span><span class="p">,</span> <span class="n">run_err_file</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">stderr_file</span><span class="o">.</span><span class="n">path</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">scheduler_parser</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">set_status</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">S_QCRITICAL</span><span class="p">,</span> 
                                       <span class="n">msg</span><span class="o">=</span><span class="s">&quot;Cannot find scheduler_parser for qtype </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">manager</span><span class="o">.</span><span class="n">qadapter</span><span class="o">.</span><span class="n">QTYPE</span><span class="p">)</span>
                
            <span class="n">scheduler_parser</span><span class="o">.</span><span class="n">parse</span><span class="p">()</span>

            <span class="k">if</span> <span class="n">scheduler_parser</span><span class="o">.</span><span class="n">errors</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">queue_errors</span> <span class="o">=</span> <span class="n">scheduler_parser</span><span class="o">.</span><span class="n">errors</span>
                <span class="c"># the queue errors in the task</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="s">&quot;scheduler errors found:</span><span class="se">\n</span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="n">scheduler_parser</span><span class="o">.</span><span class="n">errors</span><span class="p">)</span>
                <span class="c"># self.history.critical(msg)</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">set_status</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">S_QCRITICAL</span><span class="p">,</span> <span class="n">msg</span><span class="o">=</span><span class="n">msg</span><span class="p">)</span>
                <span class="c"># The job is killed or crashed and we know what happened</span>
            <span class="k">elif</span> <span class="n">qerr_info</span><span class="p">:</span>
                <span class="c"># if only qout_info, we are not necessarily in QCRITICAL state, since there will always be info in the qout file</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">qerr_info</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="c">#logger.history.debug(&#39;found unknown queue error: %s&#39; % str(qerr_info))</span>
                    <span class="n">msg</span> <span class="o">=</span> <span class="s">&#39;found unknown queue error: </span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="n">qerr_info</span><span class="p">)</span>
                    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">set_status</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">S_QCRITICAL</span><span class="p">,</span> <span class="n">msg</span><span class="o">=</span><span class="n">msg</span><span class="p">)</span>
                    <span class="c"># The job is killed or crashed but we don&#39;t know what happened</span>
                    <span class="c"># it is set to QCritical, we will attempt to fix it by running on more resources</span>


        <span class="c"># 8) analizing the err files and abinit output did not identify a problem</span>
        <span class="c"># but if the files are not empty we do have a problem but no way of solving it:</span>
        <span class="k">if</span> <span class="n">err_msg</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">err_msg</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s">&#39;found error message:</span><span class="se">\n</span><span class="s"> </span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="n">err_msg</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">set_status</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">S_QCRITICAL</span><span class="p">,</span> <span class="n">msg</span><span class="o">=</span><span class="n">msg</span><span class="p">)</span>
            <span class="c"># The job is killed or crashed but we don&#39;t know what happend</span>
            <span class="c"># it is set to QCritical, we will attempt to fix it by running on more resources</span>

        <span class="c"># 9) if we still haven&#39;t returned there is no indication of any error and the job can only still be running</span>
        <span class="c"># but we should actually never land here, or we have delays in the file system ....</span>
        <span class="c"># print(&#39;the job still seems to be running maybe it is hanging without producing output... &#39;)</span>

        <span class="c"># Check time of last modification.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_file</span><span class="o">.</span><span class="n">exists</span> <span class="ow">and</span> \
           <span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_file</span><span class="o">.</span><span class="n">get_stat</span><span class="p">()</span><span class="o">.</span><span class="n">st_mtime</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">manager</span><span class="o">.</span><span class="n">policy</span><span class="o">.</span><span class="n">frozen_timeout</span><span class="p">):</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s">&quot;Task seems to be frozen, last change more than </span><span class="si">%s</span><span class="s"> [s] ago&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">manager</span><span class="o">.</span><span class="n">policy</span><span class="o">.</span><span class="n">frozen_timeout</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">set_status</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">S_ERROR</span><span class="p">,</span> <span class="n">msg</span><span class="o">=</span><span class="n">msg</span><span class="p">)</span>

        <span class="c"># Handle weird case in which either run.abo, or run.log have not been produced</span>
        <span class="c">#if self.status not in (self.S_INIT, self.S_READY) and (not self.output.file.exists or not self.log_file.exits):</span>
        <span class="c">#    msg = &quot;Task have been submitted but cannot find the log file or the output file&quot;</span>
        <span class="c">#    return self.set_status(self.S_ERROR, msg)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">set_status</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">S_RUN</span><span class="p">,</span> <span class="n">msg</span><span class="o">=</span><span class="s">&#39;final option: nothing seems to be wrong, the job must still be running&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">reduce_memory_demand</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Method that can be called by the scheduler to decrease the memory demand of a specific task.</span>
<span class="sd">        Returns True in case of success, False in case of Failure.</span>
<span class="sd">        Should be overwritten by specific tasks.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">False</span>

    <span class="k">def</span> <span class="nf">speed_up</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Method that can be called by the flow to decrease the time needed for a specific task.</span>
<span class="sd">        Returns True in case of success, False in case of Failure</span>
<span class="sd">        Should be overwritten by specific tasks.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">False</span>

    <span class="k">def</span> <span class="nf">out_to_in</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">out_file</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Move an output file to the output data directory of the `Task` </span>
<span class="sd">        and rename the file so that ABINIT will read it as an input data file.</span>

<span class="sd">        Returns:</span>
<span class="sd">            The absolute path of the new file in the indata directory.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">in_file</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">out_file</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s">&quot;out&quot;</span><span class="p">,</span> <span class="s">&quot;in&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">dest</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">indir</span><span class="o">.</span><span class="n">path</span><span class="p">,</span> <span class="n">in_file</span><span class="p">)</span>
                                                                           
        <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">dest</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">islink</span><span class="p">(</span><span class="n">dest</span><span class="p">):</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s">&quot;Will overwrite </span><span class="si">%s</span><span class="s"> with </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">dest</span><span class="p">,</span> <span class="n">out_file</span><span class="p">))</span>
                                                                           
        <span class="n">os</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">out_file</span><span class="p">,</span> <span class="n">dest</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">dest</span>

    <span class="k">def</span> <span class="nf">inlink_file</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filepath</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a symbolic link to the specified file in the </span>
<span class="sd">        directory containing the input files of the task.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">filepath</span><span class="p">):</span> 
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s">&quot;Creating symbolic link to not existent file </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="n">filepath</span><span class="p">)</span>

        <span class="c"># Extract the Abinit extension and add the prefix for input files.</span>
        <span class="n">root</span><span class="p">,</span> <span class="n">abiext</span> <span class="o">=</span> <span class="n">abi_splitext</span><span class="p">(</span><span class="n">filepath</span><span class="p">)</span>

        <span class="n">infile</span> <span class="o">=</span> <span class="s">&quot;in_&quot;</span> <span class="o">+</span> <span class="n">abiext</span>
        <span class="n">infile</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">indir</span><span class="o">.</span><span class="n">path_in</span><span class="p">(</span><span class="n">infile</span><span class="p">)</span>

        <span class="c"># Link path to dest if dest link does not exist.</span>
        <span class="c"># else check that it points to the expected file.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">history</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s">&quot;Linking path </span><span class="si">%s</span><span class="s"> --&gt; </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">filepath</span><span class="p">,</span> <span class="n">infile</span><span class="p">))</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">infile</span><span class="p">):</span>
            <span class="n">os</span><span class="o">.</span><span class="n">symlink</span><span class="p">(</span><span class="n">filepath</span><span class="p">,</span> <span class="n">infile</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">realpath</span><span class="p">(</span><span class="n">infile</span><span class="p">)</span> <span class="o">!=</span> <span class="n">filepath</span><span class="p">:</span>
                <span class="k">raise</span> <span class="bp">self</span><span class="o">.</span><span class="n">Error</span><span class="p">(</span><span class="s">&quot;infile </span><span class="si">%s</span><span class="s"> does not point to filepath </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">infile</span><span class="p">,</span> <span class="n">filepath</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">make_links</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create symbolic links to the output files produced by the other tasks.</span>

<span class="sd">        .. warning::</span>
<span class="sd">            </span>
<span class="sd">            This method should be called only when the calculation is READY because</span>
<span class="sd">            it uses a heuristic approach to find the file to link.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">dep</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">deps</span><span class="p">:</span>
            <span class="n">filepaths</span><span class="p">,</span> <span class="n">exts</span> <span class="o">=</span> <span class="n">dep</span><span class="o">.</span><span class="n">get_filepaths_and_exts</span><span class="p">()</span>

            <span class="k">for</span> <span class="n">path</span><span class="p">,</span> <span class="n">ext</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">filepaths</span><span class="p">,</span> <span class="n">exts</span><span class="p">):</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s">&quot;Need path </span><span class="si">%s</span><span class="s"> with ext </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">ext</span><span class="p">))</span>
                <span class="n">dest</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ipath_from_ext</span><span class="p">(</span><span class="n">ext</span><span class="p">)</span>

                <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">path</span><span class="p">):</span> 
                    <span class="c"># Try netcdf file. TODO: this case should be treated in a cleaner way.</span>
                    <span class="n">path</span> <span class="o">+=</span> <span class="s">&quot;-etsf.nc&quot;</span>
                    <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">path</span><span class="p">):</span> <span class="n">dest</span> <span class="o">+=</span> <span class="s">&quot;-etsf.nc&quot;</span>

                <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">path</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="bp">self</span><span class="o">.</span><span class="n">Error</span><span class="p">(</span><span class="s">&quot;</span><span class="si">%s</span><span class="s">: </span><span class="si">%s</span><span class="s"> is needed by this task but it does not exist&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="p">))</span>

                <span class="c"># Link path to dest if dest link does not exist.</span>
                <span class="c"># else check that it points to the expected file.</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s">&quot;Linking path </span><span class="si">%s</span><span class="s"> --&gt; </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">dest</span><span class="p">))</span>

                <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">dest</span><span class="p">):</span>
                    <span class="n">os</span><span class="o">.</span><span class="n">symlink</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">dest</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c"># check links but only if we haven&#39;t performed the restart.</span>
                    <span class="c"># in this case, indeed we may have replaced the file pointer with the </span>
                    <span class="c"># previous output file of the present task.</span>
                    <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">realpath</span><span class="p">(</span><span class="n">dest</span><span class="p">)</span> <span class="o">!=</span> <span class="n">path</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_restarts</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="bp">self</span><span class="o">.</span><span class="n">Error</span><span class="p">(</span><span class="s">&quot;dest </span><span class="si">%s</span><span class="s"> does not point to path </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">dest</span><span class="p">,</span> <span class="n">path</span><span class="p">))</span>

    <span class="nd">@abc.abstractmethod</span>
    <span class="k">def</span> <span class="nf">setup</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Public method called before submitting the task.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">_setup</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method calls self.setup after having performed additional operations</span>
<span class="sd">        such as the creation of the symbolic links needed to connect different tasks.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">make_links</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">setup</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">get_event_report</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">source</span><span class="o">=</span><span class="s">&quot;log&quot;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Analyzes the main logfile of the calculation for possible Errors or Warnings.</span>
<span class="sd">        If the ABINIT abort file is found, the error found in this file are added to</span>
<span class="sd">        the output report.</span>

<span class="sd">        Args:</span>
<span class="sd">            source: &quot;output&quot; for the main output file,&quot;log&quot; for the log file.</span>

<span class="sd">        Returns:</span>
<span class="sd">            :class:`EventReport` instance or None if the source file file does not exist.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># By default, we inspect the main log file.</span>
        <span class="n">ofile</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s">&quot;output&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_file</span><span class="p">,</span>
            <span class="s">&quot;log&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">log_file</span><span class="p">}[</span><span class="n">source</span><span class="p">]</span>

        <span class="n">parser</span> <span class="o">=</span> <span class="n">events</span><span class="o">.</span><span class="n">EventsParser</span><span class="p">()</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">ofile</span><span class="o">.</span><span class="n">exists</span><span class="p">:</span> 
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">mpiabort_file</span><span class="o">.</span><span class="n">exists</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">None</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c"># ABINIT abort file without log!</span>
                <span class="n">abort_report</span> <span class="o">=</span> <span class="n">parser</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mpiabort_file</span><span class="o">.</span><span class="n">path</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">abort_report</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">report</span> <span class="o">=</span> <span class="n">parser</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="n">ofile</span><span class="o">.</span><span class="n">path</span><span class="p">)</span>
            <span class="c">#self._prev_reports[source] = report</span>

            <span class="c"># Add events found in the ABI_MPIABORTFILE.</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mpiabort_file</span><span class="o">.</span><span class="n">exists</span><span class="p">:</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">critical</span><span class="p">(</span><span class="s">&quot;Found ABI_MPIABORTFILE!!!!!&quot;</span><span class="p">)</span>
                <span class="n">abort_report</span> <span class="o">=</span> <span class="n">parser</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mpiabort_file</span><span class="o">.</span><span class="n">path</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">abort_report</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span> 
                    <span class="n">logger</span><span class="o">.</span><span class="n">critical</span><span class="p">(</span><span class="s">&quot;Found more than one event in ABI_MPIABORTFILE&quot;</span><span class="p">)</span>

                <span class="c"># Weird case: empty abort file, let&#39;s skip the part </span>
                <span class="c"># below and hope that the log file contains the error message.</span>
                <span class="c">#if not len(abort_report): return report</span>

                <span class="c"># Add it to the initial report only if it differs </span>
                <span class="c"># from the last one found in the main log file.</span>
                <span class="n">last_abort_event</span> <span class="o">=</span> <span class="n">abort_report</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">report</span> <span class="ow">and</span> <span class="n">last_abort_event</span> <span class="o">!=</span> <span class="n">report</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span> 
                    <span class="n">report</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">last_abort_event</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">report</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">last_abort_event</span><span class="p">)</span>

            <span class="k">return</span> <span class="n">report</span>

        <span class="c">#except parser.Error as exc:</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">exc</span><span class="p">:</span>
            <span class="c"># Return a report with an error entry with info on the exception.</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s">&quot;</span><span class="si">%s</span><span class="s">: Exception while parsing ABINIT events:</span><span class="se">\n</span><span class="s"> </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">ofile</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">exc</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_status</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">S_ABICRITICAL</span><span class="p">,</span> <span class="n">msg</span><span class="o">=</span><span class="n">msg</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">parser</span><span class="o">.</span><span class="n">report_exception</span><span class="p">(</span><span class="n">ofile</span><span class="o">.</span><span class="n">path</span><span class="p">,</span> <span class="n">exc</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_results</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns :class:`NodeResults` instance.</span>
<span class="sd">        Subclasses should extend this method (if needed) by adding </span>
<span class="sd">        specialized code that performs some kind of post-processing.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># Check whether the process completed.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">returncode</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="bp">self</span><span class="o">.</span><span class="n">Error</span><span class="p">(</span><span class="s">&quot;return code is None, you should call wait, communitate or poll&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">status</span> <span class="ow">is</span> <span class="bp">None</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">status</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">S_DONE</span><span class="p">:</span>
            <span class="k">raise</span> <span class="bp">self</span><span class="o">.</span><span class="n">Error</span><span class="p">(</span><span class="s">&quot;Task is not completed&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Results</span><span class="o">.</span><span class="n">from_node</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">move</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dest</span><span class="p">,</span> <span class="n">is_abspath</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Recursively move self.workdir to another location. This is similar to the Unix &quot;mv&quot; command.</span>
<span class="sd">        The destination path must not already exist. If the destination already exists</span>
<span class="sd">        but is not a directory, it may be overwritten depending on os.rename() semantics.</span>

<span class="sd">        Be default, dest is located in the parent directory of self.workdir.</span>
<span class="sd">        Use is_abspath=True to specify an absolute path.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">is_abspath</span><span class="p">:</span>
            <span class="n">dest</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">workdir</span><span class="p">),</span> <span class="n">dest</span><span class="p">)</span>

        <span class="n">shutil</span><span class="o">.</span><span class="n">move</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">workdir</span><span class="p">,</span> <span class="n">dest</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">in_files</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return all the input data files used.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">indir</span><span class="o">.</span><span class="n">list_filepaths</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">out_files</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return all the output data files produced.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">outdir</span><span class="o">.</span><span class="n">list_filepaths</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">tmp_files</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return all the input data files produced.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">tmpdir</span><span class="o">.</span><span class="n">list_filepaths</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">path_in_workdir</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create the absolute path of filename in the top-level working directory.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">workdir</span><span class="p">,</span> <span class="n">filename</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">rename</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">src_basename</span><span class="p">,</span> <span class="n">dest_basename</span><span class="p">,</span> <span class="n">datadir</span><span class="o">=</span><span class="s">&quot;outdir&quot;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Rename a file located in datadir.</span>

<span class="sd">        src_basename and dest_basename are the basename of the source file</span>
<span class="sd">        and of the destination file, respectively.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">directory</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s">&quot;indir&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">indir</span><span class="p">,</span>
            <span class="s">&quot;outdir&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">outdir</span><span class="p">,</span>
            <span class="s">&quot;tmpdir&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">tmpdir</span><span class="p">,</span>
        <span class="p">}[</span><span class="n">datadir</span><span class="p">]</span>

        <span class="n">src</span> <span class="o">=</span> <span class="n">directory</span><span class="o">.</span><span class="n">path_in</span><span class="p">(</span><span class="n">src_basename</span><span class="p">)</span>
        <span class="n">dest</span> <span class="o">=</span> <span class="n">directory</span><span class="o">.</span><span class="n">path_in</span><span class="p">(</span><span class="n">dest_basename</span><span class="p">)</span>

        <span class="n">os</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="n">dest</span><span class="p">)</span>

    <span class="c">#@check_spectator</span>
    <span class="k">def</span> <span class="nf">build</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates the working directory and the input files of the :class:`Task`.</span>
<span class="sd">        It does not overwrite files if they already exist.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># Create dirs for input, output and tmp data.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">indir</span><span class="o">.</span><span class="n">makedirs</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">outdir</span><span class="o">.</span><span class="n">makedirs</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tmpdir</span><span class="o">.</span><span class="n">makedirs</span><span class="p">()</span>

        <span class="c"># Write files file and input file.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">files_file</span><span class="o">.</span><span class="n">exists</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">files_file</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">filesfile_string</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">input_file</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">make_input</span><span class="p">())</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">manager</span><span class="o">.</span><span class="n">write_jobfile</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="c">#@check_spectator</span>
    <span class="k">def</span> <span class="nf">rmtree</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">exclude_wildcard</span><span class="o">=</span><span class="s">&quot;&quot;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Remove all files and directories in the working directory</span>

<span class="sd">        Args:</span>
<span class="sd">            exclude_wildcard: Optional string with regular expressions separated by |.</span>
<span class="sd">                Files matching one of the regular expressions will be preserved.</span>
<span class="sd">                example: exclude_wildcard=&quot;*.nc|*.txt&quot; preserves all the files whose extension is in [&quot;nc&quot;, &quot;txt&quot;].</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">exclude_wildcard</span><span class="p">:</span>
            <span class="n">shutil</span><span class="o">.</span><span class="n">rmtree</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">workdir</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">w</span> <span class="o">=</span> <span class="n">WildCard</span><span class="p">(</span><span class="n">exclude_wildcard</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">dirpath</span><span class="p">,</span> <span class="n">dirnames</span><span class="p">,</span> <span class="n">filenames</span> <span class="ow">in</span> <span class="n">os</span><span class="o">.</span><span class="n">walk</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">workdir</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">fname</span> <span class="ow">in</span> <span class="n">filenames</span><span class="p">:</span>
                    <span class="n">filepath</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">dirpath</span><span class="p">,</span> <span class="n">fname</span><span class="p">)</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">w</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">fname</span><span class="p">):</span>
                        <span class="n">os</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">filepath</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">remove_files</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">filenames</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Remove all the files listed in filenames.&quot;&quot;&quot;</span>
        <span class="n">filenames</span> <span class="o">=</span> <span class="n">list_strings</span><span class="p">(</span><span class="n">filenames</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">dirpath</span><span class="p">,</span> <span class="n">dirnames</span><span class="p">,</span> <span class="n">fnames</span> <span class="ow">in</span> <span class="n">os</span><span class="o">.</span><span class="n">walk</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">workdir</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">fname</span> <span class="ow">in</span> <span class="n">fnames</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">fname</span> <span class="ow">in</span> <span class="n">filenames</span><span class="p">:</span>
                    <span class="n">filepath</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">dirpath</span><span class="p">,</span> <span class="n">fname</span><span class="p">)</span>
                    <span class="n">os</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">filepath</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">clean_output_files</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">follow_parents</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method is called when the task reaches S_OK. It removes all the output files </span>
<span class="sd">        produced by the task that are not needed by its children as well as the output files</span>
<span class="sd">        produced by its parents if no other node needs them.</span>

<span class="sd">        Args:</span>
<span class="sd">            follow_parents: If true, the output files of the parents nodes will be removed if possible.</span>
<span class="sd">            </span>
<span class="sd">        Return:</span>
<span class="sd">            list with the absolute paths of the files that have been removed.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">paths</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">status</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">S_OK</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s">&quot;Calling task.clean_output_files on a task whose status != S_OK&quot;</span><span class="p">)</span>

        <span class="c"># Remove all files in tmpdir.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tmpdir</span><span class="o">.</span><span class="n">clean</span><span class="p">()</span>

        <span class="c"># Find the file extensions that should be preserved since these files are still </span>
        <span class="c"># needed by the children who haven&#39;t reached S_OK</span>
        <span class="n">except_exts</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_children</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">child</span><span class="o">.</span><span class="n">status</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">S_OK</span><span class="p">:</span> <span class="k">continue</span>
            <span class="c"># Find the position of self in child.deps and add the extensions.</span>
            <span class="n">i</span> <span class="o">=</span> <span class="p">[</span><span class="n">dep</span><span class="o">.</span><span class="n">node</span> <span class="k">for</span> <span class="n">dep</span> <span class="ow">in</span> <span class="n">child</span><span class="o">.</span><span class="n">deps</span><span class="p">]</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> 
            <span class="n">except_exts</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">child</span><span class="o">.</span><span class="n">deps</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">exts</span><span class="p">)</span>

        <span class="c"># Remove the files in the outdir of the task but keep except_exts. </span>
        <span class="n">exts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gc</span><span class="o">.</span><span class="n">exts</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="n">except_exts</span><span class="p">)</span>
        <span class="c">#print(&quot;Will remove its extensions: &quot;, exts)</span>
        <span class="n">paths</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">outdir</span><span class="o">.</span><span class="n">remove_exts</span><span class="p">(</span><span class="n">exts</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">follow_parents</span><span class="p">:</span> <span class="k">return</span> <span class="n">paths</span>

        <span class="c"># Remove the files in the outdir of my parents if all the possible dependencies have been fulfilled.</span>
        <span class="k">for</span> <span class="n">parent</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_parents</span><span class="p">():</span>

            <span class="c"># Here we build a dictionary file extension --&gt; list of child nodes requiring this file from parent</span>
            <span class="c"># e.g {&quot;WFK&quot;: [node1, node2]}</span>
            <span class="n">ext2nodes</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">parent</span><span class="o">.</span><span class="n">get_children</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">child</span><span class="o">.</span><span class="n">status</span> <span class="o">==</span> <span class="n">child</span><span class="o">.</span><span class="n">S_OK</span><span class="p">:</span> <span class="k">continue</span>
                <span class="n">i</span> <span class="o">=</span> <span class="p">[</span><span class="n">d</span><span class="o">.</span><span class="n">node</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">child</span><span class="o">.</span><span class="n">deps</span><span class="p">]</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">parent</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">ext</span> <span class="ow">in</span> <span class="n">child</span><span class="o">.</span><span class="n">deps</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">exts</span><span class="p">:</span>
                    <span class="n">ext2nodes</span><span class="p">[</span><span class="n">ext</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">child</span><span class="p">)</span>
        
            <span class="c"># Remove extension only if no node depends on it!</span>
            <span class="n">except_exts</span> <span class="o">=</span> <span class="p">[</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">lst</span> <span class="ow">in</span> <span class="n">ext2nodes</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">lst</span><span class="p">]</span>
            <span class="n">exts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gc</span><span class="o">.</span><span class="n">exts</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="n">except_exts</span><span class="p">)</span>
            <span class="c">#print(&quot;%s removes extensions %s from parent node %s&quot; % (self, exts, parent))</span>
            <span class="n">paths</span> <span class="o">+=</span> <span class="n">parent</span><span class="o">.</span><span class="n">outdir</span><span class="o">.</span><span class="n">remove_exts</span><span class="p">(</span><span class="n">exts</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">history</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s">&quot;Removed files: </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="n">paths</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">paths</span>

    <span class="k">def</span> <span class="nf">setup</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Base class does not provide any hook.&quot;&quot;&quot;</span>

    <span class="c">#@check_spectator</span>
    <span class="k">def</span> <span class="nf">start</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Starts the calculation by performing the following steps:</span>

<span class="sd">            - build dirs and files</span>
<span class="sd">            - call the _setup method</span>
<span class="sd">            - execute the job file by executing/submitting the job script.</span>

<span class="sd">        Main entry point for the `Launcher`.</span>

<span class="sd">        ==============  ==============================================================</span>
<span class="sd">        kwargs          Meaning</span>
<span class="sd">        ==============  ==============================================================</span>
<span class="sd">        autoparal       False to skip the autoparal step (default True)</span>
<span class="sd">        exec_args       List of arguments passed to executable.</span>
<span class="sd">        ==============  ==============================================================</span>

<span class="sd">        Returns:</span>
<span class="sd">            1 if task was started, 0 otherwise.</span>
<span class="sd">            </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">status</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">S_SUB</span><span class="p">:</span>
            <span class="k">raise</span> <span class="bp">self</span><span class="o">.</span><span class="n">Error</span><span class="p">(</span><span class="s">&quot;Task status: </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">status</span><span class="p">))</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">start_lockfile</span><span class="o">.</span><span class="n">exists</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">history</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s">&quot;Found lock file: </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">start_lockfile</span><span class="o">.</span><span class="n">path</span><span class="p">)</span>
            <span class="k">return</span> <span class="mi">0</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">start_lockfile</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&quot;Started on </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="n">time</span><span class="o">.</span><span class="n">asctime</span><span class="p">())</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">build</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_setup</span><span class="p">()</span>

        <span class="c"># Add the variables needed to connect the node.</span>
        <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">deps</span><span class="p">:</span>
            <span class="n">cvars</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">connecting_vars</span><span class="p">()</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s">&quot;Adding connecting vars </span><span class="si">%s</span><span class="s"> &quot;</span> <span class="o">%</span> <span class="n">cvars</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_set_inpvars</span><span class="p">(</span><span class="n">cvars</span><span class="p">)</span>

            <span class="c"># Get (python) data from other nodes</span>
            <span class="n">d</span><span class="o">.</span><span class="n">apply_getters</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="c"># Automatic parallelization</span>
        <span class="k">if</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s">&quot;autoparal&quot;</span><span class="p">,</span> <span class="bp">True</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s">&quot;autoparal_run&quot;</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">autoparal_run</span><span class="p">()</span>
            <span class="k">except</span> <span class="n">QueueAdapterError</span> <span class="k">as</span> <span class="n">exc</span><span class="p">:</span>
                <span class="c"># If autoparal cannot find a qadapter to run the calculation raises an Exception</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">history</span><span class="o">.</span><span class="n">critical</span><span class="p">(</span><span class="n">exc</span><span class="p">)</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="s">&quot;Error trying to find a running configuration:</span><span class="se">\n</span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="n">straceback</span><span class="p">()</span>
                <span class="c">#logger.critical(msg)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">set_status</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">S_QCRITICAL</span><span class="p">,</span> <span class="n">msg</span><span class="o">=</span><span class="n">msg</span><span class="p">)</span>
                <span class="k">return</span> <span class="mi">0</span>
            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">exc</span><span class="p">:</span>
                <span class="c"># Sometimes autoparal_run fails because Abinit aborts</span>
                <span class="c"># at the level of the parser e.g. cannot find the spacegroup</span>
                <span class="c"># due to some numerical noise in the structure.</span>
                <span class="c"># In this case we call fix_abicritical and then we try to run autoparal again.</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">history</span><span class="o">.</span><span class="n">critical</span><span class="p">(</span><span class="s">&quot;First call to autoparal failed with `</span><span class="si">%s</span><span class="s">`. Will try fix_abicritical&quot;</span> <span class="o">%</span> <span class="n">exc</span><span class="p">)</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="s">&quot;autoparal_fake_run raised:</span><span class="se">\n</span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="n">straceback</span><span class="p">()</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">critical</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

                <span class="n">fixed</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fix_abicritical</span><span class="p">()</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">fixed</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">set_status</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">S_ABICRITICAL</span><span class="p">,</span> <span class="n">msg</span><span class="o">=</span><span class="s">&quot;fix_abicritical could not solve the problem&quot;</span><span class="p">)</span>
                    <span class="k">return</span> <span class="mi">0</span>

                <span class="k">try</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">autoparal_run</span><span class="p">()</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">history</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s">&quot;Second call to autoparal succeeded!&quot;</span><span class="p">)</span>

                <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">exc</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">history</span><span class="o">.</span><span class="n">critical</span><span class="p">(</span><span class="s">&quot;Second call to autoparal failed with </span><span class="si">%s</span><span class="s">. Cannot recover!&quot;</span><span class="p">,</span> <span class="n">exc</span><span class="p">)</span>
                    <span class="n">msg</span> <span class="o">=</span> <span class="s">&quot;Tried autoparal again but got:</span><span class="se">\n</span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="n">straceback</span><span class="p">()</span>
                    <span class="c"># logger.critical(msg)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">set_status</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">S_ABICRITICAL</span><span class="p">,</span> <span class="n">msg</span><span class="o">=</span><span class="n">msg</span><span class="p">)</span>
                    <span class="k">return</span> <span class="mi">0</span>

        <span class="c"># Start the calculation in a subprocess and return.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_process</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">manager</span><span class="o">.</span><span class="n">launch</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="mi">1</span>

    <span class="k">def</span> <span class="nf">start_and_wait</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Helper method to start the task and wait for completetion.</span>

<span class="sd">        Mainly used when we are submitting the task via the shell without passing through a queue manager.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">start</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">retcode</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">wait</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">retcode</span>


<span class="k">class</span> <span class="nc">DecreaseDemandsError</span><span class="p">(</span><span class="ne">Exception</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    exception to be raised by a task if the request to decrease some demand, load or memory, could not be performed</span>
<span class="sd">    &quot;&quot;&quot;</span>


<span class="k">class</span> <span class="nc">AbinitTask</span><span class="p">(</span><span class="n">Task</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Base class defining an ABINIT calculation</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">Results</span> <span class="o">=</span> <span class="n">TaskResults</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_input</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="nb">input</span><span class="p">,</span> <span class="n">workdir</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">manager</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create an instance of `AbinitTask` from an ABINIT input.</span>
<span class="sd">    </span>
<span class="sd">        Args:</span>
<span class="sd">            ainput: `AbinitInput` object.</span>
<span class="sd">            workdir: Path to the working directory.</span>
<span class="sd">            manager: :class:`TaskManager` object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">cls</span><span class="p">(</span><span class="nb">input</span><span class="p">,</span> <span class="n">workdir</span><span class="o">=</span><span class="n">workdir</span><span class="p">,</span> <span class="n">manager</span><span class="o">=</span><span class="n">manager</span><span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">temp_shell_task</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">inp</span><span class="p">,</span> <span class="n">workdir</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">manager</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Build a Task with a temporary workdir. The task is executed via the shell with 1 MPI proc.</span>
<span class="sd">        Mainly used for invoking Abinit to get important parameters needed to prepare the real task.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># Build a simple manager to run the job in a shell subprocess</span>
        <span class="kn">import</span> <span class="nn">tempfile</span>
        <span class="n">workdir</span> <span class="o">=</span> <span class="n">tempfile</span><span class="o">.</span><span class="n">mkdtemp</span><span class="p">()</span> <span class="k">if</span> <span class="n">workdir</span> <span class="ow">is</span> <span class="bp">None</span> <span class="k">else</span> <span class="n">workdir</span>  
        <span class="k">if</span> <span class="n">manager</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span> <span class="n">manager</span> <span class="o">=</span> <span class="n">TaskManager</span><span class="o">.</span><span class="n">from_user_config</span><span class="p">()</span>

        <span class="c"># Construct the task and run it</span>
        <span class="n">task</span> <span class="o">=</span> <span class="n">cls</span><span class="o">.</span><span class="n">from_input</span><span class="p">(</span><span class="n">inp</span><span class="p">,</span> <span class="n">workdir</span><span class="o">=</span><span class="n">workdir</span><span class="p">,</span> <span class="n">manager</span><span class="o">=</span><span class="n">manager</span><span class="o">.</span><span class="n">to_shell_manager</span><span class="p">(</span><span class="n">mpi_procs</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
        <span class="n">task</span><span class="o">.</span><span class="n">set_name</span><span class="p">(</span><span class="s">&#39;temp_shell_task&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">task</span>

    <span class="k">def</span> <span class="nf">setup</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Abinit has the very *bad* habit of changing the file extension by appending the characters in [A,B ..., Z] </span>
<span class="sd">        to the output file, and this breaks a lot of code that relies of the use of a unique file extension.</span>
<span class="sd">        Here we fix this issue by renaming run.abo to run.abo_[number] if the output file &quot;run.abo&quot; already</span>
<span class="sd">        exists. A few lines of code in python, a lot of problems if you try to implement this trick in Fortran90. </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">def</span> <span class="nf">rename_file</span><span class="p">(</span><span class="n">afile</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;Helper function to rename :class:`File` objects. Return string for logging purpose.&quot;&quot;&quot;</span>
            <span class="c"># Find the index of the last file (if any).</span>
            <span class="c"># TODO: Maybe it&#39;s better to use run.abo --&gt; run(1).abo</span>
            <span class="n">fnames</span> <span class="o">=</span> <span class="p">[</span><span class="n">f</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">os</span><span class="o">.</span><span class="n">listdir</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">workdir</span><span class="p">)</span> <span class="k">if</span> <span class="n">f</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="n">afile</span><span class="o">.</span><span class="n">basename</span><span class="p">)]</span>
            <span class="n">nums</span> <span class="o">=</span> <span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">f</span><span class="p">)</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="p">[</span><span class="n">f</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">&quot;_&quot;</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">fnames</span><span class="p">]</span> <span class="k">if</span> <span class="n">f</span><span class="o">.</span><span class="n">isdigit</span><span class="p">()]</span>
            <span class="n">last</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span> <span class="k">if</span> <span class="n">nums</span> <span class="k">else</span> <span class="mi">0</span>
            <span class="n">new_path</span> <span class="o">=</span> <span class="n">afile</span><span class="o">.</span><span class="n">path</span> <span class="o">+</span> <span class="s">&quot;_&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">last</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
                                                                                                      
            <span class="n">os</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">afile</span><span class="o">.</span><span class="n">path</span><span class="p">,</span> <span class="n">new_path</span><span class="p">)</span>
            <span class="k">return</span> <span class="s">&quot;Will rename </span><span class="si">%s</span><span class="s"> to </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">afile</span><span class="o">.</span><span class="n">path</span><span class="p">,</span> <span class="n">new_path</span><span class="p">)</span>

        <span class="n">logs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_file</span><span class="o">.</span><span class="n">exists</span><span class="p">:</span> <span class="n">logs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">rename_file</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">output_file</span><span class="p">))</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">log_file</span><span class="o">.</span><span class="n">exists</span><span class="p">:</span> <span class="n">logs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">rename_file</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">log_file</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">logs</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">history</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">logs</span><span class="p">))</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">executable</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Path to the executable required for running the Task.&quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_executable</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="k">return</span> <span class="s">&quot;abinit&quot;</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">pseudos</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;List of pseudos used in the calculation.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">input</span><span class="o">.</span><span class="n">pseudos</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">isnc</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;True if norm-conserving calculation.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">input</span><span class="o">.</span><span class="n">isnc</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">ispaw</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;True if PAW calculation&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">input</span><span class="o">.</span><span class="n">ispaw</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">filesfile_string</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;String with the list of files and prefixes needed to execute ABINIT.&quot;&quot;&quot;</span>
        <span class="n">lines</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">app</span> <span class="o">=</span> <span class="n">lines</span><span class="o">.</span><span class="n">append</span>
        <span class="n">pj</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span>

        <span class="n">app</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">input_file</span><span class="o">.</span><span class="n">path</span><span class="p">)</span>                 <span class="c"># Path to the input file</span>
        <span class="n">app</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">output_file</span><span class="o">.</span><span class="n">path</span><span class="p">)</span>                <span class="c"># Path to the output file</span>
        <span class="n">app</span><span class="p">(</span><span class="n">pj</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">workdir</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">prefix</span><span class="o">.</span><span class="n">idata</span><span class="p">))</span>  <span class="c"># Prefix for input data</span>
        <span class="n">app</span><span class="p">(</span><span class="n">pj</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">workdir</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">prefix</span><span class="o">.</span><span class="n">odata</span><span class="p">))</span>  <span class="c"># Prefix for output data</span>
        <span class="n">app</span><span class="p">(</span><span class="n">pj</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">workdir</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">prefix</span><span class="o">.</span><span class="n">tdata</span><span class="p">))</span>  <span class="c"># Prefix for temporary data</span>

        <span class="c"># Paths to the pseudopotential files.</span>
        <span class="c"># Note that here the pseudos **must** be sorted according to znucl.</span>
        <span class="c"># Here we reorder the pseudos if the order is wrong.</span>
        <span class="n">ord_pseudos</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">znucl</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">input</span><span class="o">.</span><span class="n">structure</span><span class="o">.</span><span class="n">to_abivars</span><span class="p">()[</span><span class="s">&quot;znucl&quot;</span><span class="p">]</span>

        <span class="k">for</span> <span class="n">z</span> <span class="ow">in</span> <span class="n">znucl</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">pseudos</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">p</span><span class="o">.</span><span class="n">Z</span> <span class="o">==</span> <span class="n">z</span><span class="p">:</span>
                    <span class="n">ord_pseudos</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
                    <span class="k">break</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;Cannot find pseudo with znucl </span><span class="si">%s</span><span class="s"> in pseudos:</span><span class="se">\n</span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">pseudos</span><span class="p">))</span>

        <span class="k">for</span> <span class="n">pseudo</span> <span class="ow">in</span> <span class="n">ord_pseudos</span><span class="p">:</span>
            <span class="n">app</span><span class="p">(</span><span class="n">pseudo</span><span class="o">.</span><span class="n">path</span><span class="p">)</span>

        <span class="k">return</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">lines</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">set_pconfs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pconfs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set the list of autoparal configurations.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_pconfs</span> <span class="o">=</span> <span class="n">pconfs</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">pconfs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;List of autoparal configurations.&quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pconfs</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">None</span>

    <span class="k">def</span> <span class="nf">uses_paral_kgb</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;True if the task is a GS Task and uses paral_kgb with the given value.&quot;&quot;&quot;</span>
        <span class="n">paral_kgb</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_inpvar</span><span class="p">(</span><span class="s">&quot;paral_kgb&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="c"># paral_kgb is used only in the GS part.</span>
        <span class="k">return</span> <span class="n">paral_kgb</span> <span class="o">==</span> <span class="n">value</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">GsTask</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_change_structure</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new_structure</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Change the input structure.&quot;&quot;&quot;</span>
        <span class="c"># Compare new and old structure for logging purpose.</span>
        <span class="c"># TODO: Write method of structure to compare self and other and return a dictionary</span>
        <span class="n">old_structure</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">input</span><span class="o">.</span><span class="n">structure</span>
        <span class="n">old_lattice</span> <span class="o">=</span> <span class="n">old_structure</span><span class="o">.</span><span class="n">lattice</span> 

        <span class="n">abc_diff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">new_structure</span><span class="o">.</span><span class="n">lattice</span><span class="o">.</span><span class="n">abc</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">old_lattice</span><span class="o">.</span><span class="n">abc</span><span class="p">)</span>
        <span class="n">angles_diff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">new_structure</span><span class="o">.</span><span class="n">lattice</span><span class="o">.</span><span class="n">angles</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">old_lattice</span><span class="o">.</span><span class="n">angles</span><span class="p">)</span>
        <span class="n">cart_diff</span> <span class="o">=</span> <span class="n">new_structure</span><span class="o">.</span><span class="n">cart_coords</span> <span class="o">-</span> <span class="n">old_structure</span><span class="o">.</span><span class="n">cart_coords</span>
        <span class="n">displs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">v</span><span class="p">))</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">cart_diff</span><span class="p">])</span>

        <span class="n">recs</span><span class="p">,</span> <span class="n">tol_angle</span><span class="p">,</span> <span class="n">tol_length</span> <span class="o">=</span> <span class="p">[],</span> <span class="mi">10</span><span class="o">**-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">10</span><span class="o">**-</span><span class="mi">5</span>

        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">angles_diff</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">tol_angle</span><span class="p">):</span> 
            <span class="n">recs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s">&quot;new_agles - old_angles = </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="n">angles_diff</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">abc_diff</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">tol_length</span><span class="p">):</span> 
            <span class="n">recs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s">&quot;new_abc - old_abc = </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="n">abc_diff</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">displs</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">tol_length</span><span class="p">):</span>
            <span class="n">min_pos</span><span class="p">,</span> <span class="n">max_pos</span> <span class="o">=</span> <span class="n">displs</span><span class="o">.</span><span class="n">argmin</span><span class="p">(),</span> <span class="n">displs</span><span class="o">.</span><span class="n">argmax</span><span class="p">()</span>
            <span class="n">recs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s">&quot;Mean displ: </span><span class="si">%.2E</span><span class="s">, Max_displ: </span><span class="si">%.2E</span><span class="s"> (site </span><span class="si">%d</span><span class="s">), min_displ: </span><span class="si">%.2E</span><span class="s"> (site </span><span class="si">%d</span><span class="s">)&quot;</span> <span class="o">%</span> 
                <span class="p">(</span><span class="n">displs</span><span class="o">.</span><span class="n">mean</span><span class="p">(),</span> <span class="n">displs</span><span class="p">[</span><span class="n">max_pos</span><span class="p">],</span> <span class="n">max_pos</span><span class="p">,</span> <span class="n">displs</span><span class="p">[</span><span class="n">min_pos</span><span class="p">],</span> <span class="n">min_pos</span><span class="p">))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">history</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s">&quot;Changing structure (only significant diffs are shown):&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">recs</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">history</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s">&quot;Input and output structure seems to be equal within the given tolerances&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">rec</span> <span class="ow">in</span> <span class="n">recs</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">history</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="n">rec</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">input</span><span class="o">.</span><span class="n">set_structure</span><span class="p">(</span><span class="n">new_structure</span><span class="p">)</span>
        <span class="c">#assert self.input.structure == new_structure</span>

    <span class="k">def</span> <span class="nf">autoparal_run</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Find an optimal set of parameters for the execution of the task </span>
<span class="sd">        This method can change the ABINIT input variables and/or the</span>
<span class="sd">        submission parameters e.g. the number of CPUs for MPI and OpenMp.</span>

<span class="sd">        Set:</span>
<span class="sd">           self.pconfs where pconfs is a :class:`ParalHints` object with the configuration reported by</span>
<span class="sd">           autoparal and optimal is the optimal configuration selected.</span>
<span class="sd">           Returns 0 if success</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">policy</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">manager</span><span class="o">.</span><span class="n">policy</span>

        <span class="k">if</span> <span class="n">policy</span><span class="o">.</span><span class="n">autoparal</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="c"># or policy.max_ncpus in [None, 1]:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s">&quot;Nothing to do in autoparal, returning (None, None)&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="mi">1</span>

        <span class="k">if</span> <span class="n">policy</span><span class="o">.</span><span class="n">autoparal</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s">&quot;autoparal != 1&quot;</span><span class="p">)</span>

        <span class="c">############################################################################</span>
        <span class="c"># Run ABINIT in sequential to get the possible configurations with max_ncpus</span>
        <span class="c">############################################################################</span>

        <span class="c"># Set the variables for automatic parallelization</span>
        <span class="c"># Will get all the possible configurations up to max_ncpus</span>
        <span class="c"># Return immediately if max_ncpus == 1 </span>
        <span class="n">max_ncpus</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">manager</span><span class="o">.</span><span class="n">max_cores</span>
        <span class="k">if</span> <span class="n">max_ncpus</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span> <span class="k">return</span> <span class="mi">0</span>

        <span class="n">autoparal_vars</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">autoparal</span><span class="o">=</span><span class="n">policy</span><span class="o">.</span><span class="n">autoparal</span><span class="p">,</span> <span class="n">max_ncpus</span><span class="o">=</span><span class="n">max_ncpus</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_set_inpvars</span><span class="p">(</span><span class="n">autoparal_vars</span><span class="p">)</span>

        <span class="c"># Run the job in a shell subprocess with mpi_procs = 1</span>
        <span class="c"># we don&#39;t want to make a request to the queue manager for this simple job!</span>
        <span class="c"># Return code is always != 0 </span>
        <span class="n">process</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">manager</span><span class="o">.</span><span class="n">to_shell_manager</span><span class="p">(</span><span class="n">mpi_procs</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">launch</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">history</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
        <span class="n">retcode</span> <span class="o">=</span> <span class="n">process</span><span class="o">.</span><span class="n">wait</span><span class="p">()</span>

        <span class="c"># Remove the variables added for the automatic parallelization</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">input</span><span class="o">.</span><span class="n">remove_vars</span><span class="p">(</span><span class="n">autoparal_vars</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>

        <span class="c">##############################################################</span>
        <span class="c"># Parse the autoparal configurations from the main output file</span>
        <span class="c">##############################################################</span>
        <span class="n">parser</span> <span class="o">=</span> <span class="n">ParalHintsParser</span><span class="p">()</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">pconfs</span> <span class="o">=</span> <span class="n">parser</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">output_file</span><span class="o">.</span><span class="n">path</span><span class="p">)</span>
        <span class="k">except</span> <span class="n">parser</span><span class="o">.</span><span class="n">Error</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">critical</span><span class="p">(</span><span class="s">&quot;Error while parsing Autoparal section:</span><span class="se">\n</span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="n">straceback</span><span class="p">())</span>
            <span class="k">return</span> <span class="mi">2</span>

        <span class="c">######################################################</span>
        <span class="c"># Select the optimal configuration according to policy</span>
        <span class="c">######################################################</span>
        <span class="n">optconf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">find_optconf</span><span class="p">(</span><span class="n">pconfs</span><span class="p">)</span>

        <span class="c">####################################################</span>
        <span class="c"># Change the input file and/or the submission script</span>
        <span class="c">####################################################</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_set_inpvars</span><span class="p">(</span><span class="n">optconf</span><span class="o">.</span><span class="n">vars</span><span class="p">)</span>

        <span class="c"># Write autoparal configurations to JSON file.</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">pconfs</span><span class="o">.</span><span class="n">as_dict</span><span class="p">()</span>
        <span class="n">d</span><span class="p">[</span><span class="s">&quot;optimal_conf&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">optconf</span>
        <span class="n">json_pretty_dump</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">workdir</span><span class="p">,</span> <span class="s">&quot;autoparal.json&quot;</span><span class="p">))</span>

        <span class="c">##############</span>
        <span class="c"># Finalization</span>
        <span class="c">##############</span>
        <span class="c"># Reset the status, remove garbage files ...</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_status</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">S_INIT</span><span class="p">,</span> <span class="n">msg</span><span class="o">=</span><span class="s">&#39;finished auto paralell&#39;</span><span class="p">)</span>

        <span class="c"># Remove the output file since Abinit likes to create new files </span>
        <span class="c"># with extension .outA, .outB if the file already exists.</span>
        <span class="n">os</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">output_file</span><span class="o">.</span><span class="n">path</span><span class="p">)</span>
        <span class="n">os</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">log_file</span><span class="o">.</span><span class="n">path</span><span class="p">)</span>
        <span class="n">os</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stderr_file</span><span class="o">.</span><span class="n">path</span><span class="p">)</span>

        <span class="k">return</span> <span class="mi">0</span>

    <span class="k">def</span> <span class="nf">find_optconf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pconfs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Find the optimal Parallel configuration.&quot;&quot;&quot;</span>
        <span class="c"># Save pconfs for future reference.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_pconfs</span><span class="p">(</span><span class="n">pconfs</span><span class="p">)</span>
                                                                                
        <span class="c"># Select the partition on which we&#39;ll be running and set MPI/OMP cores.</span>
        <span class="n">optconf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">manager</span><span class="o">.</span><span class="n">select_qadapter</span><span class="p">(</span><span class="n">pconfs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">optconf</span>

    <span class="k">def</span> <span class="nf">select_files</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">what</span><span class="o">=</span><span class="s">&quot;o&quot;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Helper function used to select the files of a task.</span>

<span class="sd">        Args:</span>
<span class="sd">            what: string with the list of characters selecting the file type</span>
<span class="sd">                  Possible choices:</span>
<span class="sd">                    i ==&gt; input_file,</span>
<span class="sd">                    o ==&gt; output_file,</span>
<span class="sd">                    f ==&gt; files_file,</span>
<span class="sd">                    j ==&gt; job_file,</span>
<span class="sd">                    l ==&gt; log_file,</span>
<span class="sd">                    e ==&gt; stderr_file,</span>
<span class="sd">                    q ==&gt; qout_file,</span>
<span class="sd">                    all ==&gt; all files.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">choices</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">OrderedDict</span><span class="p">([</span>
            <span class="p">(</span><span class="s">&quot;i&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">input_file</span><span class="p">),</span>
            <span class="p">(</span><span class="s">&quot;o&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_file</span><span class="p">),</span>
            <span class="p">(</span><span class="s">&quot;f&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">files_file</span><span class="p">),</span>
            <span class="p">(</span><span class="s">&quot;j&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">job_file</span><span class="p">),</span>
            <span class="p">(</span><span class="s">&quot;l&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">log_file</span><span class="p">),</span>
            <span class="p">(</span><span class="s">&quot;e&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">stderr_file</span><span class="p">),</span>
            <span class="p">(</span><span class="s">&quot;q&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">qout_file</span><span class="p">),</span>
        <span class="p">])</span>

        <span class="k">if</span> <span class="n">what</span> <span class="o">==</span> <span class="s">&quot;all&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="nb">getattr</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="s">&quot;path&quot;</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">choices</span><span class="o">.</span><span class="n">values</span><span class="p">()]</span>

        <span class="n">selected</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">what</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">selected</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">choices</span><span class="p">[</span><span class="n">c</span><span class="p">],</span> <span class="s">&quot;path&quot;</span><span class="p">))</span>
            <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s">&quot;Wrong keyword </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="n">c</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">selected</span>

    <span class="k">def</span> <span class="nf">restart</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        general restart used when scheduler problems have been taken care of</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_restart</span><span class="p">()</span>

    <span class="c">#@check_spectator</span>
    <span class="k">def</span> <span class="nf">reset_from_scratch</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        restart from scratch, this is to be used if a job is restarted with more resources after a crash</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># Move output files produced in workdir to _reset otherwise check_status continues</span>
        <span class="c"># to see the task as crashed even if the job did not run</span>
        <span class="c"># Create reset directory if not already done.</span>
        <span class="n">reset_dir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">workdir</span><span class="p">,</span> <span class="s">&quot;_reset&quot;</span><span class="p">)</span>
        <span class="n">reset_file</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">reset_dir</span><span class="p">,</span> <span class="s">&quot;_counter&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">reset_dir</span><span class="p">):</span>
            <span class="n">os</span><span class="o">.</span><span class="n">mkdir</span><span class="p">(</span><span class="n">reset_dir</span><span class="p">)</span>
            <span class="n">num_reset</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">reset_file</span><span class="p">,</span> <span class="s">&quot;rt&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">fh</span><span class="p">:</span> 
                <span class="n">num_reset</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="nb">int</span><span class="p">(</span><span class="n">fh</span><span class="o">.</span><span class="n">read</span><span class="p">())</span>

        <span class="c"># Move files to reset and append digit with reset index.</span>
        <span class="k">def</span> <span class="nf">move_file</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">f</span><span class="o">.</span><span class="n">exists</span><span class="p">:</span> <span class="k">return</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">f</span><span class="o">.</span><span class="n">move</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">reset_dir</span><span class="p">,</span> <span class="n">f</span><span class="o">.</span><span class="n">basename</span> <span class="o">+</span> <span class="s">&quot;_&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">num_reset</span><span class="p">)))</span>
            <span class="k">except</span> <span class="ne">OSError</span> <span class="k">as</span> <span class="n">exc</span><span class="p">:</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s">&quot;Couldn&#39;t move file {}. exc: {}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">exc</span><span class="p">)))</span>

        <span class="k">for</span> <span class="n">fname</span> <span class="ow">in</span> <span class="p">(</span><span class="s">&quot;output_file&quot;</span><span class="p">,</span> <span class="s">&quot;log_file&quot;</span><span class="p">,</span> <span class="s">&quot;stderr_file&quot;</span><span class="p">,</span> <span class="s">&quot;qout_file&quot;</span><span class="p">,</span> <span class="s">&quot;qerr_file&quot;</span><span class="p">):</span>
            <span class="n">move_file</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fname</span><span class="p">))</span>

        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">reset_file</span><span class="p">,</span> <span class="s">&quot;wt&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">fh</span><span class="p">:</span> 
            <span class="n">fh</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">num_reset</span><span class="p">))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">start_lockfile</span><span class="o">.</span><span class="n">remove</span><span class="p">()</span>

        <span class="c"># Reset datetimes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">datetimes</span> <span class="o">=</span> <span class="n">TaskDateTimes</span><span class="p">()</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_restart</span><span class="p">(</span><span class="n">submit</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>

    <span class="c">#@check_spectator</span>
    <span class="k">def</span> <span class="nf">fix_abicritical</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        method to fix crashes/error caused by abinit</span>

<span class="sd">        Returns:</span>
<span class="sd">            1 if task has been fixed else 0.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">event_handlers</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">event_handlers</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">event_handlers</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_status</span><span class="p">(</span><span class="n">status</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">S_ERROR</span><span class="p">,</span> <span class="n">msg</span><span class="o">=</span><span class="s">&#39;Empty list of event handlers. Cannot fix abi_critical errors&#39;</span><span class="p">)</span>
            <span class="k">return</span> <span class="mi">0</span>

        <span class="n">count</span><span class="p">,</span> <span class="n">done</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">event_handlers</span><span class="p">)</span> <span class="o">*</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="n">report</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_event_report</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">report</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_status</span><span class="p">(</span><span class="n">status</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">S_ERROR</span><span class="p">,</span> <span class="n">msg</span><span class="o">=</span><span class="s">&#39;get_event_report returned None&#39;</span><span class="p">)</span>
            <span class="k">return</span> <span class="mi">0</span>

        <span class="c"># Note we have loop over all possible events (slow, I know)</span>
        <span class="c"># because we can have handlers for Error, Bug or Warning </span>
        <span class="c"># (ideally only for CriticalWarnings but this is not done yet) </span>
        <span class="k">for</span> <span class="n">event</span> <span class="ow">in</span> <span class="n">report</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">handler</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">event_handlers</span><span class="p">):</span>

                <span class="k">if</span> <span class="n">handler</span><span class="o">.</span><span class="n">can_handle</span><span class="p">(</span><span class="n">event</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">done</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s">&quot;handler </span><span class="si">%s</span><span class="s"> will try to fix event </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">handler</span><span class="p">,</span> <span class="n">event</span><span class="p">))</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">d</span> <span class="o">=</span> <span class="n">handler</span><span class="o">.</span><span class="n">handle_task_event</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">event</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">d</span><span class="p">:</span> 
                            <span class="n">done</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
                            <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>

                    <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">exc</span><span class="p">:</span>
                        <span class="n">logger</span><span class="o">.</span><span class="n">critical</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">exc</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">count</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">reset_from_scratch</span><span class="p">()</span>
            <span class="k">return</span> <span class="mi">1</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">set_status</span><span class="p">(</span><span class="n">status</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">S_ERROR</span><span class="p">,</span> <span class="n">msg</span><span class="o">=</span><span class="s">&#39;We encountered AbiCritical events that could not be fixed&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="mi">0</span>

    <span class="c">#@check_spectator</span>
    <span class="k">def</span> <span class="nf">fix_queue_critical</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function tries to fix critical events originating from the queue submission system.</span>

<span class="sd">        General strategy, first try to increase resources in order to fix the problem,</span>
<span class="sd">        if this is not possible, call a task specific method to attempt to decrease the demands.</span>

<span class="sd">        Returns:</span>
<span class="sd">            1 if task has been fixed else 0.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">pymatgen.io.abinit.scheduler_error_parsers</span> <span class="kn">import</span> <span class="n">NodeFailureError</span><span class="p">,</span> <span class="n">MemoryCancelError</span><span class="p">,</span> <span class="n">TimeCancelError</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">manager</span><span class="p">,</span> <span class="n">TaskManager</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">manager</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">queue_errors</span><span class="p">:</span>
            <span class="c"># TODO</span>
            <span class="c"># paral_kgb = 1 leads to nasty sigegv that are seen as Qcritical errors!</span>
            <span class="c"># Try to fallback to the conjugate gradient.</span>
            <span class="c">#if self.uses_paral_kgb(1):</span>
            <span class="c">#    logger.critical(&quot;QCRITICAL with PARAL_KGB==1. Will try CG!&quot;)</span>
            <span class="c">#    self._set_inpvars(paral_kgb=0)</span>
            <span class="c">#    self.reset_from_scratch()</span>
            <span class="c">#    return</span>
            <span class="c"># queue error but no errors detected, try to solve by increasing ncpus if the task scales</span>
            <span class="c"># if resources are at maximum the task is definitively turned to errored</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mem_scales</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">load_scales</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">manager</span><span class="o">.</span><span class="n">increase_resources</span><span class="p">()</span>  <span class="c"># acts either on the policy or on the qadapter</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">reset_from_scratch</span><span class="p">()</span>
                    <span class="k">return</span>
                <span class="k">except</span> <span class="n">ManagerIncreaseError</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">set_status</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">S_ERROR</span><span class="p">,</span> <span class="n">msg</span><span class="o">=</span><span class="s">&#39;unknown queue error, could not increase resources any further&#39;</span><span class="p">)</span>
                    <span class="k">raise</span> <span class="n">FixQueueCriticalError</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">set_status</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">S_ERROR</span><span class="p">,</span> <span class="n">msg</span><span class="o">=</span><span class="s">&#39;unknown queue error, no options left&#39;</span><span class="p">)</span>
                <span class="k">raise</span> <span class="n">FixQueueCriticalError</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">error</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">queue_errors</span><span class="p">:</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s">&#39;fixing: </span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="n">error</span><span class="p">))</span>

                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">error</span><span class="p">,</span> <span class="n">NodeFailureError</span><span class="p">):</span>
                    <span class="c"># if the problematic node is known, exclude it</span>
                    <span class="k">if</span> <span class="n">error</span><span class="o">.</span><span class="n">nodes</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                        <span class="k">try</span><span class="p">:</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">manager</span><span class="o">.</span><span class="n">exclude_nodes</span><span class="p">(</span><span class="n">error</span><span class="o">.</span><span class="n">nodes</span><span class="p">)</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">reset_from_scratch</span><span class="p">()</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">set_status</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">S_READY</span><span class="p">,</span> <span class="n">msg</span><span class="o">=</span><span class="s">&#39;excluding nodes&#39;</span><span class="p">)</span>
                        <span class="k">except</span><span class="p">:</span>
                            <span class="k">raise</span> <span class="n">FixQueueCriticalError</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">set_status</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">S_ERROR</span><span class="p">,</span> <span class="n">msg</span><span class="o">=</span><span class="s">&#39;Node error but no node identified.&#39;</span><span class="p">)</span>
                        <span class="k">raise</span> <span class="n">FixQueueCriticalError</span>

                <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">error</span><span class="p">,</span> <span class="n">MemoryCancelError</span><span class="p">):</span>
                    <span class="c"># ask the qadapter to provide more resources, i.e. more cpu&#39;s so more total memory if the code</span>
                    <span class="c"># scales this should fix the memeory problem</span>
                    <span class="c"># increase both max and min ncpu of the autoparalel and rerun autoparalel</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mem_scales</span><span class="p">:</span>
                        <span class="k">try</span><span class="p">:</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">manager</span><span class="o">.</span><span class="n">increase_ncpus</span><span class="p">()</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">reset_from_scratch</span><span class="p">()</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">set_status</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">S_READY</span><span class="p">,</span> <span class="n">msg</span><span class="o">=</span><span class="s">&#39;increased ncps to solve memory problem&#39;</span><span class="p">)</span>
                            <span class="k">return</span>
                        <span class="k">except</span> <span class="n">ManagerIncreaseError</span><span class="p">:</span>
                            <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s">&#39;increasing ncpus failed&#39;</span><span class="p">)</span>

                    <span class="c"># if the max is reached, try to increase the memory per cpu:</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">manager</span><span class="o">.</span><span class="n">increase_mem</span><span class="p">()</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">reset_from_scratch</span><span class="p">()</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">set_status</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">S_READY</span><span class="p">,</span> <span class="n">msg</span><span class="o">=</span><span class="s">&#39;increased mem&#39;</span><span class="p">)</span>
                        <span class="k">return</span>
                    <span class="k">except</span> <span class="n">ManagerIncreaseError</span><span class="p">:</span>
                        <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s">&#39;increasing mem failed&#39;</span><span class="p">)</span>

                    <span class="c"># if this failed ask the task to provide a method to reduce the memory demand</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">reduce_memory_demand</span><span class="p">()</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">reset_from_scratch</span><span class="p">()</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">set_status</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">S_READY</span><span class="p">,</span> <span class="n">msg</span><span class="o">=</span><span class="s">&#39;decreased mem demand&#39;</span><span class="p">)</span>
                        <span class="k">return</span>
                    <span class="k">except</span> <span class="n">DecreaseDemandsError</span><span class="p">:</span>
                        <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s">&#39;decreasing demands failed&#39;</span><span class="p">)</span>

                    <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="s">&#39;Memory error detected but the memory could not be increased neigther could the</span><span class="se">\n</span><span class="s">&#39;</span>
                           <span class="s">&#39;memory demand be decreased. Unrecoverable error.&#39;</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">set_status</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">S_ERROR</span><span class="p">,</span> <span class="n">msg</span><span class="p">)</span>
                    <span class="k">raise</span> <span class="n">FixQueueCriticalError</span>

                <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">error</span><span class="p">,</span> <span class="n">TimeCancelError</span><span class="p">):</span>
                    <span class="c"># ask the qadapter to provide more time</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">manager</span><span class="o">.</span><span class="n">increase_time</span><span class="p">()</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">reset_from_scratch</span><span class="p">()</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">set_status</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">S_READY</span><span class="p">,</span> <span class="n">msg</span><span class="o">=</span><span class="s">&#39;increased wall time&#39;</span><span class="p">)</span>
                        <span class="k">return</span>
                    <span class="k">except</span> <span class="n">ManagerIncreaseError</span><span class="p">:</span>
                        <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s">&#39;increasing the waltime failed&#39;</span><span class="p">)</span>

                    <span class="c"># if this fails ask the qadapter to increase the number of cpus</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">load_scales</span><span class="p">:</span>
                        <span class="k">try</span><span class="p">:</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">manager</span><span class="o">.</span><span class="n">increase_ncpus</span><span class="p">()</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">reset_from_scratch</span><span class="p">()</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">set_status</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">S_READY</span><span class="p">,</span> <span class="n">msg</span><span class="o">=</span><span class="s">&#39;increased number of cpus&#39;</span><span class="p">)</span>
                            <span class="k">return</span>
                        <span class="k">except</span> <span class="n">ManagerIncreaseError</span><span class="p">:</span>
                            <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s">&#39;increase ncpus to speed up the calculation to stay in the walltime failed&#39;</span><span class="p">)</span>

                    <span class="c"># if this failed ask the task to provide a method to speed up the task</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">speed_up</span><span class="p">()</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">reset_from_scratch</span><span class="p">()</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">set_status</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">S_READY</span><span class="p">,</span> <span class="n">msg</span><span class="o">=</span><span class="s">&#39;task speedup&#39;</span><span class="p">)</span>
                        <span class="k">return</span>
                    <span class="k">except</span> <span class="n">DecreaseDemandsError</span><span class="p">:</span>
                        <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s">&#39;decreasing demands failed&#39;</span><span class="p">)</span>

                    <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="s">&#39;Time cancel error detected but the time could not be increased neither could</span><span class="se">\n</span><span class="s">&#39;</span>
                           <span class="s">&#39;the time demand be decreased by speedup of increasing the number of cpus.</span><span class="se">\n</span><span class="s">&#39;</span>
                           <span class="s">&#39;Unrecoverable error.&#39;</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">set_status</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">S_ERROR</span><span class="p">,</span> <span class="n">msg</span><span class="p">)</span>

                <span class="k">else</span><span class="p">:</span>
                    <span class="n">msg</span> <span class="o">=</span> <span class="s">&#39;No solution provided for error </span><span class="si">%s</span><span class="s">. Unrecoverable error.&#39;</span> <span class="o">%</span> <span class="n">error</span><span class="o">.</span><span class="n">name</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">set_status</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">S_ERROR</span><span class="p">,</span> <span class="n">msg</span><span class="p">)</span>

        <span class="k">return</span> <span class="mi">0</span>

    <span class="k">def</span> <span class="nf">get_abitimer</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Parse the timer data in the main output file of Abinit.</span>

<span class="sd">        Return: :class:`AbinitTimerParser` instance, None if error.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">.abitimer</span> <span class="kn">import</span> <span class="n">AbinitTimerParser</span>
        <span class="n">parser</span> <span class="o">=</span> <span class="n">AbinitTimerParser</span><span class="p">()</span> 
        <span class="n">read_ok</span> <span class="o">=</span> <span class="n">parser</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">output_file</span><span class="o">.</span><span class="n">path</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">read_ok</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">parser</span>
        <span class="k">return</span> <span class="bp">None</span>


<span class="k">class</span> <span class="nc">ProduceHist</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Mixin class for an :class:`AbinitTask` producing a HIST file.</span>
<span class="sd">    Provide the method `open_hist` that reads and return a HIST file.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">hist_path</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Absolute path of the HIST file. Empty string if file is not present.&quot;&quot;&quot;</span>
        <span class="c"># Lazy property to avoid multiple calls to has_abiext.</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hist_path</span> 
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="n">path</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">outdir</span><span class="o">.</span><span class="n">has_abiext</span><span class="p">(</span><span class="s">&quot;HIST&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">path</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hist_path</span> <span class="o">=</span> <span class="n">path</span>
            <span class="k">return</span> <span class="n">path</span>

    <span class="k">def</span> <span class="nf">open_hist</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Open the HIST file located in the in self.outdir.</span>
<span class="sd">        Returns :class:`HistFile` object, None if file could not be found or file is not readable.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">hist_path</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">status</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">S_OK</span><span class="p">:</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">critical</span><span class="p">(</span><span class="s">&quot;</span><span class="si">%s</span><span class="s"> reached S_OK but didn&#39;t produce a HIST file in </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">outdir</span><span class="p">))</span>
            <span class="k">return</span> <span class="bp">None</span>

        <span class="c"># Open the HIST file</span>
        <span class="kn">from</span> <span class="nn">abipy.dynamics.hist</span> <span class="kn">import</span> <span class="n">HistFile</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">HistFile</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">hist_path</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">exc</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">critical</span><span class="p">(</span><span class="s">&quot;Exception while reading HIST file at </span><span class="si">%s</span><span class="s">:</span><span class="se">\n</span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">hist_path</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">exc</span><span class="p">)))</span>
            <span class="k">return</span> <span class="bp">None</span>


<span class="k">class</span> <span class="nc">GsTask</span><span class="p">(</span><span class="n">AbinitTask</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Base class for ground-state tasks. A ground state task produces a GSR file</span>
<span class="sd">    Provides the method `open_gsr` that reads and returns a GSR file.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">gsr_path</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Absolute path of the GSR file. Empty string if file is not present.&quot;&quot;&quot;</span>
        <span class="c"># Lazy property to avoid multiple calls to has_abiext.</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_gsr_path</span> 
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="n">path</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">outdir</span><span class="o">.</span><span class="n">has_abiext</span><span class="p">(</span><span class="s">&quot;GSR&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">path</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_gsr_path</span> <span class="o">=</span> <span class="n">path</span>
            <span class="k">return</span> <span class="n">path</span>

    <span class="k">def</span> <span class="nf">open_gsr</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Open the GSR file located in the in self.outdir.</span>
<span class="sd">        Returns :class:`GsrFile` object, None if file could not be found or file is not readable.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">gsr_path</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gsr_path</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">gsr_path</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">status</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">S_OK</span><span class="p">:</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">critical</span><span class="p">(</span><span class="s">&quot;</span><span class="si">%s</span><span class="s"> reached S_OK but didn&#39;t produce a GSR file in </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">outdir</span><span class="p">))</span>
            <span class="k">return</span> <span class="bp">None</span>

        <span class="c"># Open the GSR file.</span>
        <span class="kn">from</span> <span class="nn">abipy.electrons.gsr</span> <span class="kn">import</span> <span class="n">GsrFile</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">GsrFile</span><span class="p">(</span><span class="n">gsr_path</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">exc</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">critical</span><span class="p">(</span><span class="s">&quot;Exception while reading GSR file at </span><span class="si">%s</span><span class="s">:</span><span class="se">\n</span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">gsr_path</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">exc</span><span class="p">)))</span>
            <span class="k">return</span> <span class="bp">None</span>


<div class="viewcode-block" id="ScfTask"><a class="viewcode-back" href="../../../../pymatgen.io.abinit.html#pymatgen.io.abinit.tasks.ScfTask">[docs]</a><span class="k">class</span> <span class="nc">ScfTask</span><span class="p">(</span><span class="n">GsTask</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Self-consistent ground-state calculations.</span>
<span class="sd">    Provide support for in-place restart via (WFK|DEN) files</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">CRITICAL_EVENTS</span> <span class="o">=</span> <span class="p">[</span>
        <span class="n">events</span><span class="o">.</span><span class="n">ScfConvergenceWarning</span><span class="p">,</span>
    <span class="p">]</span>

    <span class="n">color_rgb</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="mi">255</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span> <span class="o">/</span> <span class="mi">255</span>

<div class="viewcode-block" id="ScfTask.restart"><a class="viewcode-back" href="../../../../pymatgen.io.abinit.html#pymatgen.io.abinit.tasks.ScfTask.restart">[docs]</a>    <span class="k">def</span> <span class="nf">restart</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;SCF calculations can be restarted if we have either the WFK file or the DEN file.&quot;&quot;&quot;</span>
        <span class="c"># Prefer WFK over DEN files since we can reuse the wavefunctions.</span>
        <span class="k">for</span> <span class="n">ext</span> <span class="ow">in</span> <span class="p">(</span><span class="s">&quot;WFK&quot;</span><span class="p">,</span> <span class="s">&quot;DEN&quot;</span><span class="p">):</span>
            <span class="n">restart_file</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">outdir</span><span class="o">.</span><span class="n">has_abiext</span><span class="p">(</span><span class="n">ext</span><span class="p">)</span>
            <span class="n">irdvars</span> <span class="o">=</span> <span class="n">irdvars_for_ext</span><span class="p">(</span><span class="n">ext</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">restart_file</span><span class="p">:</span> <span class="k">break</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="bp">self</span><span class="o">.</span><span class="n">RestartError</span><span class="p">(</span><span class="s">&quot;</span><span class="si">%s</span><span class="s">: Cannot find WFK or DEN file to restart from.&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="p">)</span>

        <span class="c"># Move out --&gt; in.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">out_to_in</span><span class="p">(</span><span class="n">restart_file</span><span class="p">)</span>

        <span class="c"># Add the appropriate variable for restarting.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_set_inpvars</span><span class="p">(</span><span class="n">irdvars</span><span class="p">)</span>

        <span class="c"># Now we can resubmit the job.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">history</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s">&quot;Will restart from </span><span class="si">%s</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">restart_file</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_restart</span><span class="p">()</span></div>

<div class="viewcode-block" id="ScfTask.inspect"><a class="viewcode-back" href="../../../../pymatgen.io.abinit.html#pymatgen.io.abinit.tasks.ScfTask.inspect">[docs]</a>    <span class="k">def</span> <span class="nf">inspect</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plot the SCF cycle results with matplotlib.</span>

<span class="sd">        Returns</span>
<span class="sd">            `matplotlib` figure, None if some error occurred.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">scf_cycle</span> <span class="o">=</span> <span class="n">abiinspect</span><span class="o">.</span><span class="n">GroundStateScfCycle</span><span class="o">.</span><span class="n">from_file</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">output_file</span><span class="o">.</span><span class="n">path</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">IOError</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">None</span>

        <span class="k">if</span> <span class="n">scf_cycle</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="s">&quot;title&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span> <span class="n">kwargs</span><span class="p">[</span><span class="s">&quot;title&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">scf_cycle</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">None</span></div>

<div class="viewcode-block" id="ScfTask.get_results"><a class="viewcode-back" href="../../../../pymatgen.io.abinit.html#pymatgen.io.abinit.tasks.ScfTask.get_results">[docs]</a>    <span class="k">def</span> <span class="nf">get_results</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">results</span> <span class="o">=</span> <span class="nb">super</span><span class="p">(</span><span class="n">ScfTask</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">get_results</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="c"># Open the GSR file and add its data to results.out</span>
        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">open_gsr</span><span class="p">()</span> <span class="k">as</span> <span class="n">gsr</span><span class="p">:</span>
            <span class="n">results</span><span class="p">[</span><span class="s">&quot;out&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">gsr</span><span class="o">.</span><span class="n">as_dict</span><span class="p">())</span>
            <span class="c"># Add files to GridFS</span>
            <span class="n">results</span><span class="o">.</span><span class="n">register_gridfs_files</span><span class="p">(</span><span class="n">GSR</span><span class="o">=</span><span class="n">gsr</span><span class="o">.</span><span class="n">filepath</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">results</span></div></div>


<div class="viewcode-block" id="NscfTask"><a class="viewcode-back" href="../../../../pymatgen.io.abinit.html#pymatgen.io.abinit.tasks.NscfTask">[docs]</a><span class="k">class</span> <span class="nc">NscfTask</span><span class="p">(</span><span class="n">GsTask</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Non-Self-consistent GS calculation. Provide in-place restart via WFK files</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">CRITICAL_EVENTS</span> <span class="o">=</span> <span class="p">[</span>
        <span class="n">events</span><span class="o">.</span><span class="n">NscfConvergenceWarning</span><span class="p">,</span>
    <span class="p">]</span>

    <span class="n">color_rgb</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="mi">255</span><span class="p">,</span> <span class="mi">122</span><span class="p">,</span> <span class="mi">122</span><span class="p">))</span> <span class="o">/</span> <span class="mi">255</span>

<div class="viewcode-block" id="NscfTask.restart"><a class="viewcode-back" href="../../../../pymatgen.io.abinit.html#pymatgen.io.abinit.tasks.NscfTask.restart">[docs]</a>    <span class="k">def</span> <span class="nf">restart</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;NSCF calculations can be restarted only if we have the WFK file.&quot;&quot;&quot;</span>
        <span class="n">ext</span> <span class="o">=</span> <span class="s">&quot;WFK&quot;</span>
        <span class="n">restart_file</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">outdir</span><span class="o">.</span><span class="n">has_abiext</span><span class="p">(</span><span class="n">ext</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">restart_file</span><span class="p">:</span>
            <span class="k">raise</span> <span class="bp">self</span><span class="o">.</span><span class="n">RestartError</span><span class="p">(</span><span class="s">&quot;</span><span class="si">%s</span><span class="s">: Cannot find the WFK file to restart from.&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="p">)</span>

        <span class="c"># Move out --&gt; in.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">out_to_in</span><span class="p">(</span><span class="n">restart_file</span><span class="p">)</span>

        <span class="c"># Add the appropriate variable for restarting.</span>
        <span class="n">irdvars</span> <span class="o">=</span> <span class="n">irdvars_for_ext</span><span class="p">(</span><span class="n">ext</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_set_inpvars</span><span class="p">(</span><span class="n">irdvars</span><span class="p">)</span>

        <span class="c"># Now we can resubmit the job.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">history</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s">&quot;Will restart from </span><span class="si">%s</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">restart_file</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_restart</span><span class="p">()</span></div>

<div class="viewcode-block" id="NscfTask.get_results"><a class="viewcode-back" href="../../../../pymatgen.io.abinit.html#pymatgen.io.abinit.tasks.NscfTask.get_results">[docs]</a>    <span class="k">def</span> <span class="nf">get_results</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">results</span> <span class="o">=</span> <span class="nb">super</span><span class="p">(</span><span class="n">NscfTask</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">get_results</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="c"># Read the GSR file.</span>
        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">open_gsr</span><span class="p">()</span> <span class="k">as</span> <span class="n">gsr</span><span class="p">:</span>
            <span class="n">results</span><span class="p">[</span><span class="s">&quot;out&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">gsr</span><span class="o">.</span><span class="n">as_dict</span><span class="p">())</span>
            <span class="c"># Add files to GridFS</span>
            <span class="n">results</span><span class="o">.</span><span class="n">register_gridfs_files</span><span class="p">(</span><span class="n">GSR</span><span class="o">=</span><span class="n">gsr</span><span class="o">.</span><span class="n">filepath</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">results</span></div></div>


<div class="viewcode-block" id="RelaxTask"><a class="viewcode-back" href="../../../../pymatgen.io.abinit.html#pymatgen.io.abinit.tasks.RelaxTask">[docs]</a><span class="k">class</span> <span class="nc">RelaxTask</span><span class="p">(</span><span class="n">GsTask</span><span class="p">,</span> <span class="n">ProduceHist</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Task for structural optimizations.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c"># TODO possible ScfConvergenceWarning?</span>
    <span class="n">CRITICAL_EVENTS</span> <span class="o">=</span> <span class="p">[</span>
        <span class="n">events</span><span class="o">.</span><span class="n">RelaxConvergenceWarning</span><span class="p">,</span>
    <span class="p">]</span>

    <span class="n">color_rgb</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="mi">255</span><span class="p">,</span> <span class="mi">61</span><span class="p">,</span> <span class="mi">255</span><span class="p">))</span> <span class="o">/</span> <span class="mi">255</span>

<div class="viewcode-block" id="RelaxTask.get_final_structure"><a class="viewcode-back" href="../../../../pymatgen.io.abinit.html#pymatgen.io.abinit.tasks.RelaxTask.get_final_structure">[docs]</a>    <span class="k">def</span> <span class="nf">get_final_structure</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Read the final structure from the GSR file.&quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">open_gsr</span><span class="p">()</span> <span class="k">as</span> <span class="n">gsr</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">gsr</span><span class="o">.</span><span class="n">structure</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s">&quot;Cannot find the GSR file with the final structure to restart from.&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="RelaxTask.restart"><a class="viewcode-back" href="../../../../pymatgen.io.abinit.html#pymatgen.io.abinit.tasks.RelaxTask.restart">[docs]</a>    <span class="k">def</span> <span class="nf">restart</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Restart the structural relaxation.</span>

<span class="sd">        Structure relaxations can be restarted only if we have the WFK file or the DEN or the GSR file.</span>
<span class="sd">        from which we can read the last structure (mandatory) and the wavefunctions (not mandatory but useful).</span>
<span class="sd">        Prefer WFK over other files since we can reuse the wavefunctions.</span>

<span class="sd">        .. note::</span>

<span class="sd">            The problem in the present approach is that some parameters in the input</span>
<span class="sd">            are computed from the initial structure and may not be consisten with</span>
<span class="sd">            the modification of the structure done during the structure relaxation.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">restart_file</span> <span class="o">=</span> <span class="bp">None</span>

        <span class="c"># Try to restart from the WFK file if possible.</span>
        <span class="c"># FIXME: This part has been disabled because WFK=IO is a mess if paral_kgb == 1</span>
        <span class="c"># This is also the reason why I wrote my own MPI-IO code for the GW part!</span>
        <span class="n">wfk_file</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">outdir</span><span class="o">.</span><span class="n">has_abiext</span><span class="p">(</span><span class="s">&quot;WFK&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">False</span> <span class="ow">and</span> <span class="n">wfk_file</span><span class="p">:</span>
            <span class="n">irdvars</span> <span class="o">=</span> <span class="n">irdvars_for_ext</span><span class="p">(</span><span class="s">&quot;WFK&quot;</span><span class="p">)</span>
            <span class="n">restart_file</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">out_to_in</span><span class="p">(</span><span class="n">wfk_file</span><span class="p">)</span>

        <span class="c"># Fallback to DEN file. Note that here we look for out_DEN instead of out_TIM?_DEN</span>
        <span class="c"># This happens when the previous run completed and task.on_done has been performed.</span>
        <span class="c"># ********************************************************************************</span>
        <span class="c"># Note that it&#39;s possible to have an undected error if we have multiple restarts</span>
        <span class="c"># and the last relax died badly. In this case indeed out_DEN is the file produced </span>
        <span class="c"># by the last run that has executed on_done.</span>
        <span class="c"># ********************************************************************************</span>
        <span class="k">if</span> <span class="n">restart_file</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">out_den</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">outdir</span><span class="o">.</span><span class="n">path_in</span><span class="p">(</span><span class="s">&quot;out_DEN&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">out_den</span><span class="p">):</span>
                <span class="n">irdvars</span> <span class="o">=</span> <span class="n">irdvars_for_ext</span><span class="p">(</span><span class="s">&quot;DEN&quot;</span><span class="p">)</span>
                <span class="n">restart_file</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">out_to_in</span><span class="p">(</span><span class="n">out_den</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">restart_file</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="c"># Try to restart from the last TIM?_DEN file.</span>
            <span class="c"># This should happen if the previous run didn&#39;t complete in clean way.</span>
            <span class="c"># Find the last TIM?_DEN file.</span>
            <span class="n">last_timden</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">outdir</span><span class="o">.</span><span class="n">find_last_timden_file</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">last_timden</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">ofile</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">outdir</span><span class="o">.</span><span class="n">path_in</span><span class="p">(</span><span class="s">&quot;out_DEN&quot;</span><span class="p">)</span>
                <span class="n">os</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">last_timden</span><span class="o">.</span><span class="n">path</span><span class="p">,</span> <span class="n">ofile</span><span class="p">)</span>
                <span class="n">restart_file</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">out_to_in</span><span class="p">(</span><span class="n">ofile</span><span class="p">)</span>
                <span class="n">irdvars</span> <span class="o">=</span> <span class="n">irdvars_for_ext</span><span class="p">(</span><span class="s">&quot;DEN&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">restart_file</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="c"># Don&#39;t raise RestartError as we can still change the structure.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">history</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s">&quot;Cannot find the WFK|DEN|TIM?_DEN file to restart from.&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c"># Add the appropriate variable for restarting.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_set_inpvars</span><span class="p">(</span><span class="n">irdvars</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">history</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s">&quot;Will restart from </span><span class="si">%s</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">restart_file</span><span class="p">)</span>

        <span class="c"># FIXME Here we should read the HIST file but restartxf if broken!</span>
        <span class="c">#self._set_inpvars({&quot;restartxf&quot;: -1})</span>

        <span class="c"># Read the relaxed structure from the GSR file and change the input.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_change_structure</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_final_structure</span><span class="p">())</span>

        <span class="c"># Now we can resubmit the job.</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_restart</span><span class="p">()</span></div>

<div class="viewcode-block" id="RelaxTask.inspect"><a class="viewcode-back" href="../../../../pymatgen.io.abinit.html#pymatgen.io.abinit.tasks.RelaxTask.inspect">[docs]</a>    <span class="k">def</span> <span class="nf">inspect</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plot the evolution of the structural relaxation with matplotlib.</span>

<span class="sd">        Args:</span>
<span class="sd">            what: Either &quot;hist&quot; or &quot;scf&quot;. The first option (default) extracts data</span>
<span class="sd">                from the HIST file and plot the evolution of the structural </span>
<span class="sd">                parameters, forces, pressures and energies.</span>
<span class="sd">                The second option, extracts data from the main output file and</span>
<span class="sd">                plot the evolution of the SCF cycles (etotal, residuals, etc).</span>

<span class="sd">        Returns:</span>
<span class="sd">            `matplotlib` figure, None if some error occurred. </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">what</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s">&quot;what&quot;</span><span class="p">,</span> <span class="s">&quot;hist&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">what</span> <span class="o">==</span> <span class="s">&quot;hist&quot;</span><span class="p">:</span>
            <span class="c"># Read the hist file to get access to the structure.</span>
            <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">open_hist</span><span class="p">()</span> <span class="k">as</span> <span class="n">hist</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">hist</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="k">if</span> <span class="n">hist</span> <span class="k">else</span> <span class="bp">None</span>

        <span class="k">elif</span> <span class="n">what</span> <span class="o">==</span> <span class="s">&quot;scf&quot;</span><span class="p">:</span>
            <span class="c"># Get info on the different SCF cycles </span>
            <span class="n">relaxation</span> <span class="o">=</span> <span class="n">abiinspect</span><span class="o">.</span><span class="n">Relaxation</span><span class="o">.</span><span class="n">from_file</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">output_file</span><span class="o">.</span><span class="n">path</span><span class="p">)</span>
            <span class="k">if</span> <span class="s">&quot;title&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span> <span class="n">kwargs</span><span class="p">[</span><span class="s">&quot;title&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">relaxation</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="k">if</span> <span class="n">relaxation</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="k">else</span> <span class="bp">None</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;Wrong value for what </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="n">what</span><span class="p">)</span></div>

<div class="viewcode-block" id="RelaxTask.get_results"><a class="viewcode-back" href="../../../../pymatgen.io.abinit.html#pymatgen.io.abinit.tasks.RelaxTask.get_results">[docs]</a>    <span class="k">def</span> <span class="nf">get_results</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">results</span> <span class="o">=</span> <span class="nb">super</span><span class="p">(</span><span class="n">RelaxTask</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">get_results</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="c"># Open the GSR file and add its data to results.out</span>
        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">open_gsr</span><span class="p">()</span> <span class="k">as</span> <span class="n">gsr</span><span class="p">:</span>
            <span class="n">results</span><span class="p">[</span><span class="s">&quot;out&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">gsr</span><span class="o">.</span><span class="n">as_dict</span><span class="p">())</span>
            <span class="c"># Add files to GridFS</span>
            <span class="n">results</span><span class="o">.</span><span class="n">register_gridfs_files</span><span class="p">(</span><span class="n">GSR</span><span class="o">=</span><span class="n">gsr</span><span class="o">.</span><span class="n">filepath</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">results</span></div>

<div class="viewcode-block" id="RelaxTask.reduce_dilatmx"><a class="viewcode-back" href="../../../../pymatgen.io.abinit.html#pymatgen.io.abinit.tasks.RelaxTask.reduce_dilatmx">[docs]</a>    <span class="k">def</span> <span class="nf">reduce_dilatmx</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target</span><span class="o">=</span><span class="mf">1.01</span><span class="p">):</span>
        <span class="n">actual_dilatmx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_inpvar</span><span class="p">(</span><span class="s">&#39;dilatmx&#39;</span><span class="p">,</span> <span class="mf">1.</span><span class="p">)</span>
        <span class="n">new_dilatmx</span> <span class="o">=</span> <span class="n">actual_dilatmx</span> <span class="o">-</span> <span class="nb">min</span><span class="p">((</span><span class="n">actual_dilatmx</span><span class="o">-</span><span class="n">target</span><span class="p">),</span> <span class="n">actual_dilatmx</span><span class="o">*</span><span class="mf">0.05</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_set_inpvars</span><span class="p">(</span><span class="n">dilatmx</span><span class="o">=</span><span class="n">new_dilatmx</span><span class="p">)</span></div>

<div class="viewcode-block" id="RelaxTask.fix_ofiles"><a class="viewcode-back" href="../../../../pymatgen.io.abinit.html#pymatgen.io.abinit.tasks.RelaxTask.fix_ofiles">[docs]</a>    <span class="k">def</span> <span class="nf">fix_ofiles</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Note that ABINIT produces lots of out_TIM1_DEN files for each step.</span>
<span class="sd">        Here we list all TIM*_DEN files, we select the last one and we rename it in out_DEN</span>

<span class="sd">        This change is needed so that we can specify dependencies with the syntax {node: &quot;DEN&quot;}</span>
<span class="sd">        without having to know the number of iterations needed to converge the run in node!</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">RelaxTask</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">fix_ofiles</span><span class="p">()</span>

        <span class="c"># Find the last TIM?_DEN file.</span>
        <span class="n">last_timden</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">outdir</span><span class="o">.</span><span class="n">find_last_timden_file</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">last_timden</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s">&quot;Cannot find TIM?_DEN files&quot;</span><span class="p">)</span>
            <span class="k">return</span>

        <span class="c"># Rename last TIMDEN with out_DEN.</span>
        <span class="n">ofile</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">outdir</span><span class="o">.</span><span class="n">path_in</span><span class="p">(</span><span class="s">&quot;out_DEN&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">history</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s">&quot;Renaming last_denfile </span><span class="si">%s</span><span class="s"> --&gt; </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">last_timden</span><span class="o">.</span><span class="n">path</span><span class="p">,</span> <span class="n">ofile</span><span class="p">))</span>
        <span class="n">os</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">last_timden</span><span class="o">.</span><span class="n">path</span><span class="p">,</span> <span class="n">ofile</span><span class="p">)</span></div></div>


<span class="k">class</span> <span class="nc">DfptTask</span><span class="p">(</span><span class="n">AbinitTask</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Base class for DFPT tasks (Phonons, ...)</span>
<span class="sd">    Mainly used to implement methods that are common to DFPT calculations with Abinit.</span>
<span class="sd">    Provide the method `open_ddb` that reads and return a Ddb file.</span>

<span class="sd">    .. warning::</span>

<span class="sd">        This class should not be instantiated directly.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">ddb_path</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Absolute path of the DDB file. Empty string if file is not present.&quot;&quot;&quot;</span>
        <span class="c"># Lazy property to avoid multiple calls to has_abiext.</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ddb_path</span> 
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="n">path</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">outdir</span><span class="o">.</span><span class="n">has_abiext</span><span class="p">(</span><span class="s">&quot;DDB&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">path</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ddb_path</span> <span class="o">=</span> <span class="n">path</span>
            <span class="k">return</span> <span class="n">path</span>

    <span class="k">def</span> <span class="nf">open_ddb</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Open the DDB file located in the in self.outdir.</span>
<span class="sd">        Returns :class:`DdbFile` object, None if file could not be found or file is not readable.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ddb_path</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ddb_path</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">ddb_path</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">status</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">S_OK</span><span class="p">:</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">critical</span><span class="p">(</span><span class="s">&quot;</span><span class="si">%s</span><span class="s"> reached S_OK but didn&#39;t produce a DDB file in </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">outdir</span><span class="p">))</span>
            <span class="k">return</span> <span class="bp">None</span>

        <span class="c"># Open the DDB file.</span>
        <span class="kn">from</span> <span class="nn">abipy.dfpt.ddb</span> <span class="kn">import</span> <span class="n">DdbFile</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">DdbFile</span><span class="p">(</span><span class="n">ddb_path</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">exc</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">critical</span><span class="p">(</span><span class="s">&quot;Exception while reading DDB file at </span><span class="si">%s</span><span class="s">:</span><span class="se">\n</span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">ddb_path</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">exc</span><span class="p">)))</span>
            <span class="k">return</span> <span class="bp">None</span>


<span class="c"># TODO Remove</span>
<span class="k">class</span> <span class="nc">DdeTask</span><span class="p">(</span><span class="n">DfptTask</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Task for DDE calculations.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">get_results</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">results</span> <span class="o">=</span> <span class="nb">super</span><span class="p">(</span><span class="n">DdeTask</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">get_results</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">results</span><span class="o">.</span><span class="n">register_gridfs_file</span><span class="p">(</span><span class="n">DDB</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">outdir</span><span class="o">.</span><span class="n">has_abiext</span><span class="p">(</span><span class="s">&quot;DDE&quot;</span><span class="p">),</span> <span class="s">&quot;t&quot;</span><span class="p">))</span>


<div class="viewcode-block" id="DdkTask"><a class="viewcode-back" href="../../../../pymatgen.io.abinit.html#pymatgen.io.abinit.tasks.DdkTask">[docs]</a><span class="k">class</span> <span class="nc">DdkTask</span><span class="p">(</span><span class="n">DfptTask</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Task for DDK calculations.&quot;&quot;&quot;</span>

    <span class="n">color_rgb</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="mi">61</span><span class="p">,</span> <span class="mi">158</span><span class="p">,</span> <span class="mi">255</span><span class="p">))</span> <span class="o">/</span> <span class="mi">255</span>

    <span class="c">#@check_spectator </span>
    <span class="k">def</span> <span class="nf">_on_ok</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">DdkTask</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">_on_ok</span><span class="p">()</span>
        <span class="c"># Copy instead of removing, otherwise optic tests fail</span>
        <span class="c"># Fixing this proble requires a rationalization of file extensions.</span>
        <span class="c">#if self.outdir.rename_abiext(&#39;1WF&#39;, &#39;DDK&#39;) &gt; 0:</span>
        <span class="c">#if self.outdir.copy_abiext(&#39;1WF&#39;, &#39;DDK&#39;) &gt; 0:</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">outdir</span><span class="o">.</span><span class="n">symlink_abiext</span><span class="p">(</span><span class="s">&#39;1WF&#39;</span><span class="p">,</span> <span class="s">&#39;DDK&#39;</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span>

<div class="viewcode-block" id="DdkTask.get_results"><a class="viewcode-back" href="../../../../pymatgen.io.abinit.html#pymatgen.io.abinit.tasks.DdkTask.get_results">[docs]</a>    <span class="k">def</span> <span class="nf">get_results</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">results</span> <span class="o">=</span> <span class="nb">super</span><span class="p">(</span><span class="n">DdkTask</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">get_results</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">results</span><span class="o">.</span><span class="n">register_gridfs_file</span><span class="p">(</span><span class="n">DDK</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">outdir</span><span class="o">.</span><span class="n">has_abiext</span><span class="p">(</span><span class="s">&quot;DDK&quot;</span><span class="p">),</span> <span class="s">&quot;t&quot;</span><span class="p">))</span></div></div>


<span class="k">class</span> <span class="nc">BecTask</span><span class="p">(</span><span class="n">DfptTask</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Task for the calculation of Born effective charges.</span>

<span class="sd">    bec_deps = {ddk_task: &quot;DDK&quot; for ddk_task in ddk_tasks}</span>
<span class="sd">    bec_deps.update({scf_task: &quot;WFK&quot;})</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">color_rgb</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="mi">122</span><span class="p">,</span> <span class="mi">122</span><span class="p">,</span> <span class="mi">255</span><span class="p">))</span> <span class="o">/</span> <span class="mi">255</span>

    <span class="k">def</span> <span class="nf">make_links</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Replace the default behaviour of make_links&quot;&quot;&quot;</span>
        <span class="c">#print(&quot;In BEC make_links&quot;)</span>

        <span class="k">for</span> <span class="n">dep</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">deps</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">dep</span><span class="o">.</span><span class="n">exts</span> <span class="o">==</span> <span class="p">[</span><span class="s">&quot;DDK&quot;</span><span class="p">]:</span>
                <span class="n">ddk_task</span> <span class="o">=</span> <span class="n">dep</span><span class="o">.</span><span class="n">node</span>
                <span class="n">out_ddk</span> <span class="o">=</span> <span class="n">ddk_task</span><span class="o">.</span><span class="n">outdir</span><span class="o">.</span><span class="n">has_abiext</span><span class="p">(</span><span class="s">&quot;DDK&quot;</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">out_ddk</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s">&quot;</span><span class="si">%s</span><span class="s"> didn&#39;t produce the DDK file&quot;</span> <span class="o">%</span> <span class="n">ddk_task</span><span class="p">)</span>

                <span class="c"># Get (fortran) idir and costruct the name of the 1WF expected by Abinit</span>
                <span class="n">rfdir</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">ddk_task</span><span class="o">.</span><span class="n">input</span><span class="p">[</span><span class="s">&quot;rfdir&quot;</span><span class="p">])</span>
                <span class="k">if</span> <span class="n">rfdir</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s">&quot;Only one direction should be specifned in rfdir but rfdir = </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="n">rfdir</span><span class="p">)</span>

                <span class="n">idir</span> <span class="o">=</span> <span class="n">rfdir</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
                <span class="n">ddk_case</span> <span class="o">=</span> <span class="n">idir</span> <span class="o">+</span>  <span class="mi">3</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">ddk_task</span><span class="o">.</span><span class="n">input</span><span class="o">.</span><span class="n">structure</span><span class="p">)</span>

                <span class="n">infile</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">indir</span><span class="o">.</span><span class="n">path_in</span><span class="p">(</span><span class="s">&quot;in_1WF</span><span class="si">%d</span><span class="s">&quot;</span> <span class="o">%</span> <span class="n">ddk_case</span><span class="p">)</span>
                <span class="n">os</span><span class="o">.</span><span class="n">symlink</span><span class="p">(</span><span class="n">out_ddk</span><span class="p">,</span> <span class="n">infile</span><span class="p">)</span>

            <span class="k">elif</span> <span class="n">dep</span><span class="o">.</span><span class="n">exts</span> <span class="o">==</span> <span class="p">[</span><span class="s">&quot;WFK&quot;</span><span class="p">]:</span>
                <span class="n">gs_task</span> <span class="o">=</span> <span class="n">dep</span><span class="o">.</span><span class="n">node</span>
                <span class="n">out_wfk</span> <span class="o">=</span> <span class="n">gs_task</span><span class="o">.</span><span class="n">outdir</span><span class="o">.</span><span class="n">has_abiext</span><span class="p">(</span><span class="s">&quot;WFK&quot;</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">out_wfk</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s">&quot;</span><span class="si">%s</span><span class="s"> didn&#39;t produce the WFK file&quot;</span> <span class="o">%</span> <span class="n">gs_task</span><span class="p">)</span>

                <span class="n">os</span><span class="o">.</span><span class="n">symlink</span><span class="p">(</span><span class="n">out_wfk</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">indir</span><span class="o">.</span><span class="n">path_in</span><span class="p">(</span><span class="s">&quot;in_WFK&quot;</span><span class="p">))</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;Don&#39;t know how to handle extension: </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="n">dep</span><span class="o">.</span><span class="n">exts</span><span class="p">)</span>



<div class="viewcode-block" id="PhononTask"><a class="viewcode-back" href="../../../../pymatgen.io.abinit.html#pymatgen.io.abinit.tasks.PhononTask">[docs]</a><span class="k">class</span> <span class="nc">PhononTask</span><span class="p">(</span><span class="n">DfptTask</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    DFPT calculations for a single atomic perturbation.</span>
<span class="sd">    Provide support for in-place restart via (1WF|1DEN) files</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c"># TODO: </span>
    <span class="c"># for the time being we don&#39;t discern between GS and PhononCalculations.</span>
    <span class="n">CRITICAL_EVENTS</span> <span class="o">=</span> <span class="p">[</span>
        <span class="n">events</span><span class="o">.</span><span class="n">ScfConvergenceWarning</span><span class="p">,</span>
    <span class="p">]</span>

    <span class="n">color_rgb</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">255</span><span class="p">))</span> <span class="o">/</span> <span class="mi">255</span>

<div class="viewcode-block" id="PhononTask.restart"><a class="viewcode-back" href="../../../../pymatgen.io.abinit.html#pymatgen.io.abinit.tasks.PhononTask.restart">[docs]</a>    <span class="k">def</span> <span class="nf">restart</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Phonon calculations can be restarted only if we have the 1WF file or the 1DEN file.</span>
<span class="sd">        from which we can read the first-order wavefunctions or the first order density.</span>
<span class="sd">        Prefer 1WF over 1DEN since we can reuse the wavefunctions.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># Abinit adds the idir-ipert index at the end of the file and this breaks the extension </span>
        <span class="c"># e.g. out_1WF4, out_DEN4. find_1wf_files and find_1den_files returns the list of files found</span>
        <span class="n">restart_file</span><span class="p">,</span> <span class="n">irdvars</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span> <span class="bp">None</span>

        <span class="c"># Highest priority to the 1WF file because restart is more efficient.</span>
        <span class="n">wf_files</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">outdir</span><span class="o">.</span><span class="n">find_1wf_files</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">wf_files</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">restart_file</span> <span class="o">=</span> <span class="n">wf_files</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">path</span>
            <span class="n">irdvars</span> <span class="o">=</span> <span class="n">irdvars_for_ext</span><span class="p">(</span><span class="s">&quot;1WF&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">wf_files</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">restart_file</span> <span class="o">=</span> <span class="bp">None</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">critical</span><span class="p">(</span><span class="s">&quot;Found more than one 1WF file. Restart is ambiguous!&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">restart_file</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">den_files</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">outdir</span><span class="o">.</span><span class="n">find_1den_files</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">den_files</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">restart_file</span> <span class="o">=</span> <span class="n">den_files</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">path</span>
                <span class="n">irdvars</span> <span class="o">=</span> <span class="p">{</span><span class="s">&quot;ird1den&quot;</span><span class="p">:</span> <span class="mi">1</span><span class="p">}</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">den_files</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">restart_file</span> <span class="o">=</span> <span class="bp">None</span>
                    <span class="n">logger</span><span class="o">.</span><span class="n">critical</span><span class="p">(</span><span class="s">&quot;Found more than one 1DEN file. Restart is ambiguous!&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">restart_file</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="c"># Raise because otherwise restart is equivalent to a run from scratch --&gt; infinite loop!</span>
            <span class="k">raise</span> <span class="bp">self</span><span class="o">.</span><span class="n">RestartError</span><span class="p">(</span><span class="s">&quot;</span><span class="si">%s</span><span class="s">: Cannot find the 1WF|1DEN file to restart from.&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="p">)</span>

        <span class="c"># Move file.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">history</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s">&quot;Will restart from </span><span class="si">%s</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">restart_file</span><span class="p">)</span>
        <span class="n">restart_file</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">out_to_in</span><span class="p">(</span><span class="n">restart_file</span><span class="p">)</span>

        <span class="c"># Add the appropriate variable for restarting.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_set_inpvars</span><span class="p">(</span><span class="n">irdvars</span><span class="p">)</span>

        <span class="c"># Now we can resubmit the job.</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_restart</span><span class="p">()</span></div>

<div class="viewcode-block" id="PhononTask.inspect"><a class="viewcode-back" href="../../../../pymatgen.io.abinit.html#pymatgen.io.abinit.tasks.PhononTask.inspect">[docs]</a>    <span class="k">def</span> <span class="nf">inspect</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plot the Phonon SCF cycle results with matplotlib.</span>

<span class="sd">        Returns:</span>
<span class="sd">            `matplotlib` figure, None if some error occurred.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">scf_cycle</span> <span class="o">=</span> <span class="n">abiinspect</span><span class="o">.</span><span class="n">PhononScfCycle</span><span class="o">.</span><span class="n">from_file</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">output_file</span><span class="o">.</span><span class="n">path</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">scf_cycle</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="s">&quot;title&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span> <span class="n">kwargs</span><span class="p">[</span><span class="s">&quot;title&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">scf_cycle</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="PhononTask.get_results"><a class="viewcode-back" href="../../../../pymatgen.io.abinit.html#pymatgen.io.abinit.tasks.PhononTask.get_results">[docs]</a>    <span class="k">def</span> <span class="nf">get_results</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">results</span> <span class="o">=</span> <span class="nb">super</span><span class="p">(</span><span class="n">PhononTask</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">get_results</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">results</span><span class="o">.</span><span class="n">register_gridfs_files</span><span class="p">(</span><span class="n">DDB</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">outdir</span><span class="o">.</span><span class="n">has_abiext</span><span class="p">(</span><span class="s">&quot;DDB&quot;</span><span class="p">),</span> <span class="s">&quot;t&quot;</span><span class="p">))</span></div>

<div class="viewcode-block" id="PhononTask.make_links"><a class="viewcode-back" href="../../../../pymatgen.io.abinit.html#pymatgen.io.abinit.tasks.PhononTask.make_links">[docs]</a>    <span class="k">def</span> <span class="nf">make_links</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">PhononTask</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">make_links</span><span class="p">()</span></div></div>
        <span class="c"># fix the problem that abinit uses the 1WF extension for the DDK output file but reads it with the irdddk flag</span>
        <span class="c">#if self.indir.has_abiext(&#39;DDK&#39;):</span>
        <span class="c">#    self.indir.rename_abiext(&#39;DDK&#39;, &#39;1WF&#39;)</span>


<span class="k">class</span> <span class="nc">ManyBodyTask</span><span class="p">(</span><span class="n">AbinitTask</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Base class for Many-body tasks (Screening, Sigma, Bethe-Salpeter)</span>
<span class="sd">    Mainly used to implement methods that are common to MBPT calculations with Abinit.</span>

<span class="sd">    .. warning::</span>

<span class="sd">        This class should not be instantiated directly.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">reduce_memory_demand</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Method that can be called by the scheduler to decrease the memory demand of a specific task.</span>
<span class="sd">        Returns True in case of success, False in case of Failure.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># The first digit governs the storage of W(q), the second digit the storage of u(r)</span>
        <span class="c"># Try to avoid the storage of u(r) first since reading W(q) from file will lead to a drammatic slowdown.</span>
        <span class="n">prev_gwmem</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_inpvar</span><span class="p">(</span><span class="s">&quot;gwmem&quot;</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mi">11</span><span class="p">))</span>
        <span class="n">first_dig</span><span class="p">,</span> <span class="n">second_dig</span> <span class="o">=</span> <span class="n">prev_gwmem</span> <span class="o">//</span> <span class="mi">10</span><span class="p">,</span> <span class="n">prev_gwmem</span> <span class="o">%</span> <span class="mi">10</span>

        <span class="k">if</span> <span class="n">second_dig</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_set_inpvars</span><span class="p">(</span><span class="n">gwmem</span><span class="o">=</span><span class="s">&quot;</span><span class="si">%.2d</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="mi">10</span> <span class="o">*</span> <span class="n">first_dig</span><span class="p">))</span>
            <span class="k">return</span> <span class="bp">True</span>

        <span class="k">if</span> <span class="n">first_dig</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_set_inpvars</span><span class="p">(</span><span class="n">gwmem</span><span class="o">=</span><span class="s">&quot;</span><span class="si">%.2d</span><span class="s">&quot;</span> <span class="o">%</span> <span class="mo">00</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">True</span>

        <span class="c"># gwmem 00 d&#39;oh!</span>
        <span class="k">return</span> <span class="bp">False</span>


<span class="k">class</span> <span class="nc">ScrTask</span><span class="p">(</span><span class="n">ManyBodyTask</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Tasks for SCREENING calculations &quot;&quot;&quot;</span>

    <span class="n">color_rgb</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="mi">255</span><span class="p">,</span> <span class="mi">128</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span> <span class="o">/</span> <span class="mi">255</span>

    <span class="c">#def inspect(self, **kwargs):</span>
    <span class="c">#    &quot;&quot;&quot;Plot graph showing the number of q-points computed and the wall-time used&quot;&quot;&quot;</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">scr_path</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Absolute path of the SCR file. Empty string if file is not present.&quot;&quot;&quot;</span>
        <span class="c"># Lazy property to avoid multiple calls to has_abiext.</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_scr_path</span> 
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="n">path</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">outdir</span><span class="o">.</span><span class="n">has_abiext</span><span class="p">(</span><span class="s">&quot;SCR.nc&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">path</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_scr_path</span> <span class="o">=</span> <span class="n">path</span>
            <span class="k">return</span> <span class="n">path</span>

    <span class="k">def</span> <span class="nf">open_scr</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Open the SIGRES file located in the in self.outdir. </span>
<span class="sd">        Returns SigresFile object, None if file could not be found or file is not readable.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">scr_path</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">scr_path</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">scr_path</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">critical</span><span class="p">(</span><span class="s">&quot;</span><span class="si">%s</span><span class="s"> didn&#39;t produce a SCR.nc file in </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">outdir</span><span class="p">))</span>
            <span class="k">return</span> <span class="bp">None</span>

        <span class="c"># Open the GSR file and add its data to results.out</span>
        <span class="kn">from</span> <span class="nn">abipy.electrons.scr</span> <span class="kn">import</span> <span class="n">SctFile</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">SctFile</span><span class="p">(</span><span class="n">sigres_path</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">exc</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">critical</span><span class="p">(</span><span class="s">&quot;Exception while reading SCR file at </span><span class="si">%s</span><span class="s">:</span><span class="se">\n</span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">scr_path</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">exc</span><span class="p">)))</span>
            <span class="k">return</span> <span class="bp">None</span>


<div class="viewcode-block" id="SigmaTask"><a class="viewcode-back" href="../../../../pymatgen.io.abinit.html#pymatgen.io.abinit.tasks.SigmaTask">[docs]</a><span class="k">class</span> <span class="nc">SigmaTask</span><span class="p">(</span><span class="n">ManyBodyTask</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Tasks for SIGMA calculations. Provides support for in-place restart via QPS files</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">CRITICAL_EVENTS</span> <span class="o">=</span> <span class="p">[</span>
        <span class="n">events</span><span class="o">.</span><span class="n">QPSConvergenceWarning</span><span class="p">,</span>
    <span class="p">]</span>

    <span class="n">color_rgb</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">255</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span> <span class="o">/</span> <span class="mi">255</span>

<div class="viewcode-block" id="SigmaTask.restart"><a class="viewcode-back" href="../../../../pymatgen.io.abinit.html#pymatgen.io.abinit.tasks.SigmaTask.restart">[docs]</a>    <span class="k">def</span> <span class="nf">restart</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span></div>
        <span class="c"># G calculations can be restarted only if we have the QPS file </span>
        <span class="c"># from which we can read the results of the previous step.</span>
        <span class="n">ext</span> <span class="o">=</span> <span class="s">&quot;QPS&quot;</span>
        <span class="n">restart_file</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">outdir</span><span class="o">.</span><span class="n">has_abiext</span><span class="p">(</span><span class="n">ext</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">restart_file</span><span class="p">:</span>
            <span class="k">raise</span> <span class="bp">self</span><span class="o">.</span><span class="n">RestartError</span><span class="p">(</span><span class="s">&quot;</span><span class="si">%s</span><span class="s">: Cannot find the QPS file to restart from.&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">out_to_in</span><span class="p">(</span><span class="n">restart_file</span><span class="p">)</span>

        <span class="c"># Add the appropriate variable for restarting.</span>
        <span class="n">irdvars</span> <span class="o">=</span> <span class="n">irdvars_for_ext</span><span class="p">(</span><span class="n">ext</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_set_inpvars</span><span class="p">(</span><span class="n">irdvars</span><span class="p">)</span>

        <span class="c"># Now we can resubmit the job.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">history</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s">&quot;Will restart from </span><span class="si">%s</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">restart_file</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_restart</span><span class="p">()</span>

    <span class="c">#def inspect(self, **kwargs):</span>
    <span class="c">#    &quot;&quot;&quot;Plot graph showing the number of k-points computed and the wall-time used&quot;&quot;&quot;</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">sigres_path</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Absolute path of the SIGRES file. Empty string if file is not present.&quot;&quot;&quot;</span>
        <span class="c"># Lazy property to avoid multiple calls to has_abiext.</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sigres_path</span> 
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="n">path</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">outdir</span><span class="o">.</span><span class="n">has_abiext</span><span class="p">(</span><span class="s">&quot;SIGRES&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">path</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sigres_path</span> <span class="o">=</span> <span class="n">path</span>
            <span class="k">return</span> <span class="n">path</span>

<div class="viewcode-block" id="SigmaTask.open_sigres"><a class="viewcode-back" href="../../../../pymatgen.io.abinit.html#pymatgen.io.abinit.tasks.SigmaTask.open_sigres">[docs]</a>    <span class="k">def</span> <span class="nf">open_sigres</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Open the SIGRES file located in the in self.outdir. </span>
<span class="sd">        Returns SigresFile object, None if file could not be found or file is not readable.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">sigres_path</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sigres_path</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">sigres_path</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">critical</span><span class="p">(</span><span class="s">&quot;</span><span class="si">%s</span><span class="s"> didn&#39;t produce a SIGRES file in </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">outdir</span><span class="p">))</span>
            <span class="k">return</span> <span class="bp">None</span>

        <span class="c"># Open the SIGRES file and add its data to results.out</span>
        <span class="kn">from</span> <span class="nn">abipy.electrons.gw</span> <span class="kn">import</span> <span class="n">SigresFile</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">SigresFile</span><span class="p">(</span><span class="n">sigres_path</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">exc</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">critical</span><span class="p">(</span><span class="s">&quot;Exception while reading SIGRES file at </span><span class="si">%s</span><span class="s">:</span><span class="se">\n</span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">sigres_path</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">exc</span><span class="p">)))</span>
            <span class="k">return</span> <span class="bp">None</span></div>

<div class="viewcode-block" id="SigmaTask.get_scissors_builder"><a class="viewcode-back" href="../../../../pymatgen.io.abinit.html#pymatgen.io.abinit.tasks.SigmaTask.get_scissors_builder">[docs]</a>    <span class="k">def</span> <span class="nf">get_scissors_builder</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns an instance of :class:`ScissorsBuilder` from the SIGRES file.</span>

<span class="sd">        Raise:</span>
<span class="sd">            `RuntimeError` if SIGRES file is not found.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">abipy.electrons.scissors</span> <span class="kn">import</span> <span class="n">ScissorsBuilder</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">sigres_path</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">ScissorsBuilder</span><span class="o">.</span><span class="n">from_file</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sigres_path</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s">&quot;Cannot find SIGRES file!&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="SigmaTask.get_results"><a class="viewcode-back" href="../../../../pymatgen.io.abinit.html#pymatgen.io.abinit.tasks.SigmaTask.get_results">[docs]</a>    <span class="k">def</span> <span class="nf">get_results</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">results</span> <span class="o">=</span> <span class="nb">super</span><span class="p">(</span><span class="n">SigmaTask</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">get_results</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="c"># Open the SIGRES file and add its data to results.out</span>
        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">open_sigres</span><span class="p">()</span> <span class="k">as</span> <span class="n">sigres</span><span class="p">:</span>
            <span class="c">#results[&quot;out&quot;].update(sigres.as_dict())</span>
            <span class="n">results</span><span class="o">.</span><span class="n">register_gridfs_files</span><span class="p">(</span><span class="n">SIGRES</span><span class="o">=</span><span class="n">sigres</span><span class="o">.</span><span class="n">filepath</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">results</span></div></div>


<span class="k">class</span> <span class="nc">BseTask</span><span class="p">(</span><span class="n">ManyBodyTask</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Task for Bethe-Salpeter calculations.</span>

<span class="sd">    .. note::</span>

<span class="sd">        The BSE codes provides both iterative and direct schemes for the computation of the dielectric function.</span>
<span class="sd">        The direct diagonalization cannot be restarted whereas Haydock and CG support restarting.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">CRITICAL_EVENTS</span> <span class="o">=</span> <span class="p">[</span>
        <span class="n">events</span><span class="o">.</span><span class="n">HaydockConvergenceWarning</span><span class="p">,</span>
        <span class="c">#events.BseIterativeDiagoConvergenceWarning,</span>
    <span class="p">]</span>

    <span class="n">color_rgb</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="mi">128</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">255</span><span class="p">))</span> <span class="o">/</span> <span class="mi">255</span>

    <span class="k">def</span> <span class="nf">restart</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        BSE calculations with Haydock can be restarted only if we have the</span>
<span class="sd">        excitonic Hamiltonian and the HAYDR_SAVE file.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># TODO: This version seems to work but the main output file is truncated</span>
        <span class="c"># TODO: Handle restart if CG method is used</span>
        <span class="c"># TODO: restart should receive a list of critical events</span>
        <span class="c"># the log file is complete though.</span>
        <span class="n">irdvars</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="c"># Move the BSE blocks to indata.</span>
        <span class="c"># This is done only once at the end of the first run.</span>
        <span class="c"># Successive restarts will use the BSR|BSC files in the indir directory</span>
        <span class="c"># to initialize the excitonic Hamiltonian</span>
        <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">ext</span> <span class="ow">in</span> <span class="p">(</span><span class="s">&quot;BSR&quot;</span><span class="p">,</span> <span class="s">&quot;BSC&quot;</span><span class="p">):</span>
            <span class="n">ofile</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">outdir</span><span class="o">.</span><span class="n">has_abiext</span><span class="p">(</span><span class="n">ext</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">ofile</span><span class="p">:</span>
                <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">irdvars</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">irdvars_for_ext</span><span class="p">(</span><span class="n">ext</span><span class="p">))</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">out_to_in</span><span class="p">(</span><span class="n">ofile</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">count</span><span class="p">:</span>
            <span class="c"># outdir does not contain the BSR|BSC file.</span>
            <span class="c"># This means that num_restart &gt; 1 and the files should be in task.indir</span>
            <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">ext</span> <span class="ow">in</span> <span class="p">(</span><span class="s">&quot;BSR&quot;</span><span class="p">,</span> <span class="s">&quot;BSC&quot;</span><span class="p">):</span>
                <span class="n">ifile</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">indir</span><span class="o">.</span><span class="n">has_abiext</span><span class="p">(</span><span class="n">ext</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">ifile</span><span class="p">:</span>
                    <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="n">count</span><span class="p">:</span>
                <span class="k">raise</span> <span class="bp">self</span><span class="o">.</span><span class="n">RestartError</span><span class="p">(</span><span class="s">&quot;</span><span class="si">%s</span><span class="s">: Cannot find BSR|BSC files in </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">indir</span><span class="p">))</span>

        <span class="c"># Rename HAYDR_SAVE files</span>
        <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">ext</span> <span class="ow">in</span> <span class="p">(</span><span class="s">&quot;HAYDR_SAVE&quot;</span><span class="p">,</span> <span class="s">&quot;HAYDC_SAVE&quot;</span><span class="p">):</span>
            <span class="n">ofile</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">outdir</span><span class="o">.</span><span class="n">has_abiext</span><span class="p">(</span><span class="n">ext</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">ofile</span><span class="p">:</span>
                <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">irdvars</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">irdvars_for_ext</span><span class="p">(</span><span class="n">ext</span><span class="p">))</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">out_to_in</span><span class="p">(</span><span class="n">ofile</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">count</span><span class="p">:</span>
            <span class="k">raise</span> <span class="bp">self</span><span class="o">.</span><span class="n">RestartError</span><span class="p">(</span><span class="s">&quot;</span><span class="si">%s</span><span class="s">: Cannot find the HAYDR_SAVE file to restart from.&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="p">)</span>

        <span class="c"># Add the appropriate variable for restarting.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_set_inpvars</span><span class="p">(</span><span class="n">irdvars</span><span class="p">)</span>

        <span class="c"># Now we can resubmit the job.</span>
        <span class="c">#self.history.info(&quot;Will restart from %s&quot;, restart_file)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_restart</span><span class="p">()</span>

    <span class="c">#def inspect(self, **kwargs):</span>
    <span class="c">#    &quot;&quot;&quot;</span>
    <span class="c">#    Plot the Haydock iterations with matplotlib.</span>
    <span class="c">#</span>
    <span class="c">#    Returns</span>
    <span class="c">#        `matplotlib` figure, None if some error occurred.</span>
    <span class="c">#    &quot;&quot;&quot;</span>
    <span class="c">#    haydock_cycle = abiinspect.HaydockIterations.from_file(self.output_file.path)</span>
    <span class="c">#    if haydock_cycle is not None:</span>
    <span class="c">#        if &quot;title&quot; not in kwargs: kwargs[&quot;title&quot;] = str(self)</span>
    <span class="c">#        return haydock_cycle.plot(**kwargs)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">mdf_path</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Absolute path of the MDF file. Empty string if file is not present.&quot;&quot;&quot;</span>
        <span class="c"># Lazy property to avoid multiple calls to has_abiext.</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mdf_path</span> 
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="n">path</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">outdir</span><span class="o">.</span><span class="n">has_abiext</span><span class="p">(</span><span class="s">&quot;MDF.nc&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">path</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mdf_path</span> <span class="o">=</span> <span class="n">path</span>
            <span class="k">return</span> <span class="n">path</span>

    <span class="k">def</span> <span class="nf">open_mdf</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Open the MDF file located in the in self.outdir.</span>
<span class="sd">        Returns :class:`MdfFile` object, None if file could not be found or file is not readable.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">mdf_path</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mdf_path</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">mdf_path</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">critical</span><span class="p">(</span><span class="s">&quot;</span><span class="si">%s</span><span class="s"> didn&#39;t produce a MDF file in </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">outdir</span><span class="p">))</span>
            <span class="k">return</span> <span class="bp">None</span>

        <span class="c"># Open the DFF file and add its data to results.out</span>
        <span class="kn">from</span> <span class="nn">abipy.electrons.bse</span> <span class="kn">import</span> <span class="n">MdfFile</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">MdfFile</span><span class="p">(</span><span class="n">mdf_path</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">exc</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">critical</span><span class="p">(</span><span class="s">&quot;Exception while reading MDF file at </span><span class="si">%s</span><span class="s">:</span><span class="se">\n</span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">mdf_path</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">exc</span><span class="p">)))</span>
            <span class="k">return</span> <span class="bp">None</span>

    <span class="k">def</span> <span class="nf">get_results</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">results</span> <span class="o">=</span> <span class="nb">super</span><span class="p">(</span><span class="n">BseTask</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">get_results</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">open_mdf</span><span class="p">()</span> <span class="k">as</span> <span class="n">mdf</span><span class="p">:</span>
            <span class="c">#results[&quot;out&quot;].update(mdf.as_dict())</span>
            <span class="c">#epsilon_infinity optical_gap</span>
            <span class="n">results</span><span class="o">.</span><span class="n">register_gridfs_files</span><span class="p">(</span><span class="n">MDF</span><span class="o">=</span><span class="n">mdf</span><span class="o">.</span><span class="n">filepath</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">results</span>

<div class="viewcode-block" id="OpticTask"><a class="viewcode-back" href="../../../../pymatgen.io.abinit.html#pymatgen.io.abinit.tasks.OpticTask">[docs]</a><span class="k">class</span> <span class="nc">OpticTask</span><span class="p">(</span><span class="n">Task</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Task for the computation of optical spectra with optic i.e.</span>
<span class="sd">    RPA without local-field effects and velocity operator computed from DDK files.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">color_rgb</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="mi">255</span><span class="p">,</span> <span class="mi">204</span><span class="p">,</span> <span class="mi">102</span><span class="p">))</span> <span class="o">/</span> <span class="mi">255</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">optic_input</span><span class="p">,</span> <span class="n">nscf_node</span><span class="p">,</span> <span class="n">ddk_nodes</span><span class="p">,</span> <span class="n">workdir</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">manager</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create an instance of :class:`OpticTask` from an string containing the input.</span>
<span class="sd">    </span>
<span class="sd">        Args:</span>
<span class="sd">            optic_input: string with the optic variables (filepaths will be added at run time).</span>
<span class="sd">            nscf_node: The NSCF task that will produce thw WFK file or string with the path of the WFK file.</span>
<span class="sd">            ddk_nodes: List of :class:`DdkTask` nodes that will produce the DDK files or list of DDF paths.</span>
<span class="sd">            workdir: Path to the working directory.</span>
<span class="sd">            manager: :class:`TaskManager` object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># Convert paths to FileNodes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nscf_node</span> <span class="o">=</span> <span class="n">Node</span><span class="o">.</span><span class="n">as_node</span><span class="p">(</span><span class="n">nscf_node</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ddk_nodes</span> <span class="o">=</span> <span class="p">[</span><span class="n">Node</span><span class="o">.</span><span class="n">as_node</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">ddk_nodes</span><span class="p">]</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">ddk_nodes</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span>
        <span class="c">#print(self.nscf_node, self.ddk_nodes)</span>

        <span class="c"># Use DDK extension instead of 1WF</span>
        <span class="n">deps</span> <span class="o">=</span> <span class="p">{</span><span class="n">n</span><span class="p">:</span> <span class="s">&quot;1WF&quot;</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ddk_nodes</span><span class="p">}</span>
        <span class="c">#deps = {n: &quot;DDK&quot; for n in self.ddk_nodes}</span>
        <span class="n">deps</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="bp">self</span><span class="o">.</span><span class="n">nscf_node</span><span class="p">:</span> <span class="s">&quot;WFK&quot;</span><span class="p">})</span>

        <span class="nb">super</span><span class="p">(</span><span class="n">OpticTask</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="n">optic_input</span><span class="p">,</span> <span class="n">workdir</span><span class="o">=</span><span class="n">workdir</span><span class="p">,</span> <span class="n">manager</span><span class="o">=</span><span class="n">manager</span><span class="p">,</span> <span class="n">deps</span><span class="o">=</span><span class="n">deps</span><span class="p">)</span>

<div class="viewcode-block" id="OpticTask.set_workdir"><a class="viewcode-back" href="../../../../pymatgen.io.abinit.html#pymatgen.io.abinit.tasks.OpticTask.set_workdir">[docs]</a>    <span class="k">def</span> <span class="nf">set_workdir</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">workdir</span><span class="p">,</span> <span class="n">chroot</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set the working directory of the task.&quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">OpticTask</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">set_workdir</span><span class="p">(</span><span class="n">workdir</span><span class="p">,</span> <span class="n">chroot</span><span class="o">=</span><span class="n">chroot</span><span class="p">)</span>
        <span class="c"># Small hack: the log file of optics is actually the main output file. </span>
        <span class="bp">self</span><span class="o">.</span><span class="n">output_file</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">log_file</span></div>

    <span class="k">def</span> <span class="nf">_set_inpvars</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Optic does not use `get` or `ird` variables hence we should never try </span>
<span class="sd">        to change the input when we connect this task</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">kwargs</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="nb">dict</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">history</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s">&quot;OpticTask intercepted _set_inpvars with args </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="n">kwargs</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">executable</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Path to the executable required for running the :class:`OpticTask`.&quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_executable</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="k">return</span> <span class="s">&quot;optic&quot;</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">filesfile_string</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;String with the list of files and prefixes needed to execute ABINIT.&quot;&quot;&quot;</span>
        <span class="n">lines</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">app</span> <span class="o">=</span> <span class="n">lines</span><span class="o">.</span><span class="n">append</span>

        <span class="c">#optic.in     ! Name of input file</span>
        <span class="c">#optic.out    ! Unused</span>
        <span class="c">#optic        ! Root name for all files that will be produced</span>
        <span class="n">app</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">input_file</span><span class="o">.</span><span class="n">path</span><span class="p">)</span>                           <span class="c"># Path to the input file</span>
        <span class="n">app</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">workdir</span><span class="p">,</span> <span class="s">&quot;unused&quot;</span><span class="p">))</span>           <span class="c"># Path to the output file</span>
        <span class="n">app</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">workdir</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">prefix</span><span class="o">.</span><span class="n">odata</span><span class="p">))</span>  <span class="c"># Prefix for output data</span>

        <span class="k">return</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">lines</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">wfk_filepath</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns (at runtime) the absolute path of the WFK file produced by the NSCF run.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">nscf_node</span><span class="o">.</span><span class="n">outdir</span><span class="o">.</span><span class="n">has_abiext</span><span class="p">(</span><span class="s">&quot;WFK&quot;</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">ddk_filepaths</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns (at runtime) the absolute path of the DDK files produced by the DDK runs.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">ddk_task</span><span class="o">.</span><span class="n">outdir</span><span class="o">.</span><span class="n">has_abiext</span><span class="p">(</span><span class="s">&quot;1WF&quot;</span><span class="p">)</span> <span class="k">for</span> <span class="n">ddk_task</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ddk_nodes</span><span class="p">]</span>

<div class="viewcode-block" id="OpticTask.make_input"><a class="viewcode-back" href="../../../../pymatgen.io.abinit.html#pymatgen.io.abinit.tasks.OpticTask.make_input">[docs]</a>    <span class="k">def</span> <span class="nf">make_input</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Construct and write the input file of the calculation.&quot;&quot;&quot;</span>
        <span class="c"># Set the file paths.</span>
        <span class="n">all_files</span> <span class="o">=</span><span class="p">{</span><span class="s">&quot;ddkfile_&quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="p">:</span> <span class="n">ddk</span> <span class="k">for</span> <span class="n">n</span><span class="p">,</span><span class="n">ddk</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ddk_filepaths</span><span class="p">)}</span>
        <span class="n">all_files</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="s">&quot;wfkfile&quot;</span> <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">wfk_filepath</span><span class="p">})</span>
        <span class="n">files_nml</span> <span class="o">=</span> <span class="p">{</span><span class="s">&quot;FILES&quot;</span> <span class="p">:</span> <span class="n">all_files</span><span class="p">}</span>
        <span class="n">files</span><span class="o">=</span> <span class="n">nmltostring</span><span class="p">(</span><span class="n">files_nml</span><span class="p">)</span>

        <span class="c"># Get the input specified by the user</span>
        <span class="n">user_file</span> <span class="o">=</span> <span class="n">nmltostring</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">input</span><span class="o">.</span><span class="n">as_dict</span><span class="p">())</span>

        <span class="c"># Join them.</span>
        <span class="k">return</span> <span class="n">files</span> <span class="o">+</span> <span class="n">user_file</span></div>

<div class="viewcode-block" id="OpticTask.setup"><a class="viewcode-back" href="../../../../pymatgen.io.abinit.html#pymatgen.io.abinit.tasks.OpticTask.setup">[docs]</a>    <span class="k">def</span> <span class="nf">setup</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Public method called before submitting the task.&quot;&quot;&quot;</span></div>

<div class="viewcode-block" id="OpticTask.make_links"><a class="viewcode-back" href="../../../../pymatgen.io.abinit.html#pymatgen.io.abinit.tasks.OpticTask.make_links">[docs]</a>    <span class="k">def</span> <span class="nf">make_links</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Optic allows the user to specify the paths of the input file.</span>
<span class="sd">        hence we don&#39;t need to create symbolic links.</span>
<span class="sd">        &quot;&quot;&quot;</span></div>

<div class="viewcode-block" id="OpticTask.get_results"><a class="viewcode-back" href="../../../../pymatgen.io.abinit.html#pymatgen.io.abinit.tasks.OpticTask.get_results">[docs]</a>    <span class="k">def</span> <span class="nf">get_results</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">results</span> <span class="o">=</span> <span class="nb">super</span><span class="p">(</span><span class="n">OpticTask</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">get_results</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="c">#results.update(</span>
        <span class="c">#&quot;epsilon_infinity&quot;:</span>
        <span class="c">#))</span>
        <span class="k">return</span> <span class="n">results</span></div>

<div class="viewcode-block" id="OpticTask.fix_abicritical"><a class="viewcode-back" href="../../../../pymatgen.io.abinit.html#pymatgen.io.abinit.tasks.OpticTask.fix_abicritical">[docs]</a>    <span class="k">def</span> <span class="nf">fix_abicritical</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Cannot fix abicritical errors for optic</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="mi">0</span></div></div>


<div class="viewcode-block" id="AnaddbTask"><a class="viewcode-back" href="../../../../pymatgen.io.abinit.html#pymatgen.io.abinit.tasks.AnaddbTask">[docs]</a><span class="k">class</span> <span class="nc">AnaddbTask</span><span class="p">(</span><span class="n">Task</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Task for Anaddb runs (post-processing of DFPT calculations).&quot;&quot;&quot;</span>

    <span class="n">color_rgb</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="mi">204</span><span class="p">,</span> <span class="mi">102</span><span class="p">,</span> <span class="mi">255</span><span class="p">))</span> <span class="o">/</span> <span class="mi">255</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">anaddb_input</span><span class="p">,</span> <span class="n">ddb_node</span><span class="p">,</span>
                 <span class="n">gkk_node</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">md_node</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">ddk_node</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">workdir</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">manager</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create an instance of :class:`AnaddbTask` from a string containing the input.</span>

<span class="sd">        Args:</span>
<span class="sd">            anaddb_input: string with the anaddb variables.</span>
<span class="sd">            ddb_node: The node that will produce the DDB file. Accept :class:`Task`, :class:`Work` or filepath.</span>
<span class="sd">            gkk_node: The node that will produce the GKK file (optional). Accept :class:`Task`, :class:`Work` or filepath.</span>
<span class="sd">            md_node: The node that will produce the MD file (optional). Accept `Task`, `Work` or filepath.</span>
<span class="sd">            gkk_node: The node that will produce the GKK file (optional). Accept `Task`, `Work` or filepath.</span>
<span class="sd">            workdir: Path to the working directory (optional).</span>
<span class="sd">            manager: :class:`TaskManager` object (optional).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># Keep a reference to the nodes.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ddb_node</span> <span class="o">=</span> <span class="n">Node</span><span class="o">.</span><span class="n">as_node</span><span class="p">(</span><span class="n">ddb_node</span><span class="p">)</span>
        <span class="n">deps</span> <span class="o">=</span> <span class="p">{</span><span class="bp">self</span><span class="o">.</span><span class="n">ddb_node</span><span class="p">:</span> <span class="s">&quot;DDB&quot;</span><span class="p">}</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">gkk_node</span> <span class="o">=</span> <span class="n">Node</span><span class="o">.</span><span class="n">as_node</span><span class="p">(</span><span class="n">gkk_node</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">gkk_node</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">deps</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="bp">self</span><span class="o">.</span><span class="n">gkk_node</span><span class="p">:</span> <span class="s">&quot;GKK&quot;</span><span class="p">})</span>

        <span class="c"># I never used it!</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">md_node</span> <span class="o">=</span> <span class="n">Node</span><span class="o">.</span><span class="n">as_node</span><span class="p">(</span><span class="n">md_node</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">md_node</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">deps</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="bp">self</span><span class="o">.</span><span class="n">md_node</span><span class="p">:</span> <span class="s">&quot;MD&quot;</span><span class="p">})</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">ddk_node</span> <span class="o">=</span> <span class="n">Node</span><span class="o">.</span><span class="n">as_node</span><span class="p">(</span><span class="n">ddk_node</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ddk_node</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">deps</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="bp">self</span><span class="o">.</span><span class="n">ddk_node</span><span class="p">:</span> <span class="s">&quot;DDK&quot;</span><span class="p">})</span>

        <span class="nb">super</span><span class="p">(</span><span class="n">AnaddbTask</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="nb">input</span><span class="o">=</span><span class="n">anaddb_input</span><span class="p">,</span> <span class="n">workdir</span><span class="o">=</span><span class="n">workdir</span><span class="p">,</span> <span class="n">manager</span><span class="o">=</span><span class="n">manager</span><span class="p">,</span> <span class="n">deps</span><span class="o">=</span><span class="n">deps</span><span class="p">)</span>

    <span class="nd">@classmethod</span>
<div class="viewcode-block" id="AnaddbTask.temp_shell_task"><a class="viewcode-back" href="../../../../pymatgen.io.abinit.html#pymatgen.io.abinit.tasks.AnaddbTask.temp_shell_task">[docs]</a>    <span class="k">def</span> <span class="nf">temp_shell_task</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">inp</span><span class="p">,</span> <span class="n">ddb_node</span><span class="p">,</span>
                        <span class="n">gkk_node</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">md_node</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">ddk_node</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">workdir</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">manager</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Build a :class:`AnaddbTask` with a temporary workdir. The task is executed via </span>
<span class="sd">        the shell with 1 MPI proc. Mainly used for post-processing the DDB files.</span>

<span class="sd">        Args:</span>
<span class="sd">            anaddb_input: string with the anaddb variables.</span>
<span class="sd">            ddb_node: The node that will produce the DDB file. Accept :class:`Task`, :class:`Work` or filepath.</span>

<span class="sd">        See `AnaddbInit` for the meaning of the other arguments.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># Build a simple manager to run the job in a shell subprocess</span>
        <span class="kn">import</span> <span class="nn">tempfile</span>
        <span class="n">workdir</span> <span class="o">=</span> <span class="n">tempfile</span><span class="o">.</span><span class="n">mkdtemp</span><span class="p">()</span> <span class="k">if</span> <span class="n">workdir</span> <span class="ow">is</span> <span class="bp">None</span> <span class="k">else</span> <span class="n">workdir</span>  
        <span class="k">if</span> <span class="n">manager</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span> <span class="n">manager</span> <span class="o">=</span> <span class="n">TaskManager</span><span class="o">.</span><span class="n">from_user_config</span><span class="p">()</span>

        <span class="c"># Construct the task and run it</span>
        <span class="k">return</span> <span class="n">cls</span><span class="p">(</span><span class="n">inp</span><span class="p">,</span> <span class="n">ddb_node</span><span class="p">,</span> 
                   <span class="n">gkk_node</span><span class="o">=</span><span class="n">gkk_node</span><span class="p">,</span> <span class="n">md_node</span><span class="o">=</span><span class="n">md_node</span><span class="p">,</span> <span class="n">ddk_node</span><span class="o">=</span><span class="n">ddk_node</span><span class="p">,</span>
                   <span class="n">workdir</span><span class="o">=</span><span class="n">workdir</span><span class="p">,</span> <span class="n">manager</span><span class="o">=</span><span class="n">manager</span><span class="o">.</span><span class="n">to_shell_manager</span><span class="p">(</span><span class="n">mpi_procs</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">executable</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Path to the executable required for running the :class:`AnaddbTask`.&quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_executable</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="k">return</span> <span class="s">&quot;anaddb&quot;</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">filesfile_string</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;String with the list of files and prefixes needed to execute ABINIT.&quot;&quot;&quot;</span>
        <span class="n">lines</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">app</span> <span class="o">=</span> <span class="n">lines</span><span class="o">.</span><span class="n">append</span>

        <span class="n">app</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">input_file</span><span class="o">.</span><span class="n">path</span><span class="p">)</span>          <span class="c"># 1) Path of the input file</span>
        <span class="n">app</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">output_file</span><span class="o">.</span><span class="n">path</span><span class="p">)</span>         <span class="c"># 2) Path of the output file</span>
        <span class="n">app</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ddb_filepath</span><span class="p">)</span>             <span class="c"># 3) Input derivative database e.g. t13.ddb.in</span>
        <span class="n">app</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">md_filepath</span><span class="p">)</span>              <span class="c"># 4) Output molecular dynamics e.g. t13.md</span>
        <span class="n">app</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">gkk_filepath</span><span class="p">)</span>             <span class="c"># 5) Input elphon matrix elements  (GKK file)</span>
        <span class="n">app</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">outdir</span><span class="o">.</span><span class="n">path_join</span><span class="p">(</span><span class="s">&quot;out&quot;</span><span class="p">))</span>  <span class="c"># 6) Base name for elphon output files e.g. t13</span>
        <span class="n">app</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ddk_filepath</span><span class="p">)</span>             <span class="c"># 7) File containing ddk filenames for elphon/transport.</span>

        <span class="k">return</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">lines</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">ddb_filepath</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns (at runtime) the absolute path of the input DDB file.&quot;&quot;&quot;</span>
        <span class="c"># This is not very elegant! A possible approach could to be path self.ddb_node.outdir!</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ddb_node</span><span class="p">,</span> <span class="n">FileNode</span><span class="p">):</span> <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ddb_node</span><span class="o">.</span><span class="n">filepath</span>
        <span class="n">path</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ddb_node</span><span class="o">.</span><span class="n">outdir</span><span class="o">.</span><span class="n">has_abiext</span><span class="p">(</span><span class="s">&quot;DDB&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">path</span> <span class="k">if</span> <span class="n">path</span> <span class="k">else</span> <span class="s">&quot;DDB_FILE_DOES_NOT_EXIST&quot;</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">md_filepath</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns (at runtime) the absolute path of the input MD file.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">md_node</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span> <span class="k">return</span> <span class="s">&quot;MD_FILE_DOES_NOT_EXIST&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">md_node</span><span class="p">,</span> <span class="n">FileNode</span><span class="p">):</span> <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">md_node</span><span class="o">.</span><span class="n">filepath</span>

        <span class="n">path</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">md_node</span><span class="o">.</span><span class="n">outdir</span><span class="o">.</span><span class="n">has_abiext</span><span class="p">(</span><span class="s">&quot;MD&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">path</span> <span class="k">if</span> <span class="n">path</span> <span class="k">else</span> <span class="s">&quot;MD_FILE_DOES_NOT_EXIST&quot;</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">gkk_filepath</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns (at runtime) the absolute path of the input GKK file.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">gkk_node</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span> <span class="k">return</span> <span class="s">&quot;GKK_FILE_DOES_NOT_EXIST&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">gkk_node</span><span class="p">,</span> <span class="n">FileNode</span><span class="p">):</span> <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">gkk_node</span><span class="o">.</span><span class="n">filepath</span>

        <span class="n">path</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gkk_node</span><span class="o">.</span><span class="n">outdir</span><span class="o">.</span><span class="n">has_abiext</span><span class="p">(</span><span class="s">&quot;GKK&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">path</span> <span class="k">if</span> <span class="n">path</span> <span class="k">else</span> <span class="s">&quot;GKK_FILE_DOES_NOT_EXIST&quot;</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">ddk_filepath</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns (at runtime) the absolute path of the input DKK file.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ddk_node</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span> <span class="k">return</span> <span class="s">&quot;DDK_FILE_DOES_NOT_EXIST&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ddk_node</span><span class="p">,</span> <span class="n">FileNode</span><span class="p">):</span> <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ddk_node</span><span class="o">.</span><span class="n">filepath</span>

        <span class="n">path</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ddk_node</span><span class="o">.</span><span class="n">outdir</span><span class="o">.</span><span class="n">has_abiext</span><span class="p">(</span><span class="s">&quot;DDK&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">path</span> <span class="k">if</span> <span class="n">path</span> <span class="k">else</span> <span class="s">&quot;DDK_FILE_DOES_NOT_EXIST&quot;</span>

<div class="viewcode-block" id="AnaddbTask.setup"><a class="viewcode-back" href="../../../../pymatgen.io.abinit.html#pymatgen.io.abinit.tasks.AnaddbTask.setup">[docs]</a>    <span class="k">def</span> <span class="nf">setup</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Public method called before submitting the task.&quot;&quot;&quot;</span></div>

<div class="viewcode-block" id="AnaddbTask.make_links"><a class="viewcode-back" href="../../../../pymatgen.io.abinit.html#pymatgen.io.abinit.tasks.AnaddbTask.make_links">[docs]</a>    <span class="k">def</span> <span class="nf">make_links</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Anaddb allows the user to specify the paths of the input file.</span>
<span class="sd">        hence we don&#39;t need to create symbolic links.</span>
<span class="sd">        &quot;&quot;&quot;</span></div>

<div class="viewcode-block" id="AnaddbTask.open_phbst"><a class="viewcode-back" href="../../../../pymatgen.io.abinit.html#pymatgen.io.abinit.tasks.AnaddbTask.open_phbst">[docs]</a>    <span class="k">def</span> <span class="nf">open_phbst</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Open PHBST file produced by Anaddb and returns :class:`PhbstFile` object.&quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">abipy.dfpt.phonons</span> <span class="kn">import</span> <span class="n">PhbstFile</span>
        <span class="n">phbst_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">workdir</span><span class="p">,</span> <span class="s">&quot;run.abo_PHBST.nc&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">phbst_path</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">status</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">S_OK</span><span class="p">:</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">critical</span><span class="p">(</span><span class="s">&quot;</span><span class="si">%s</span><span class="s"> reached S_OK but didn&#39;t produce a PHBST file in </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">outdir</span><span class="p">))</span>
            <span class="k">return</span> <span class="bp">None</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">PhbstFile</span><span class="p">(</span><span class="n">phbst_path</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">exc</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">critical</span><span class="p">(</span><span class="s">&quot;Exception while reading GSR file at </span><span class="si">%s</span><span class="s">:</span><span class="se">\n</span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">phbst_path</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">exc</span><span class="p">)))</span>
            <span class="k">return</span> <span class="bp">None</span></div>

<div class="viewcode-block" id="AnaddbTask.open_phdos"><a class="viewcode-back" href="../../../../pymatgen.io.abinit.html#pymatgen.io.abinit.tasks.AnaddbTask.open_phdos">[docs]</a>    <span class="k">def</span> <span class="nf">open_phdos</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Open PHDOS file produced by Anaddb and returns :class:`PhdosFile` object.&quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">abipy.dfpt.phonons</span> <span class="kn">import</span> <span class="n">PhdosFile</span>
        <span class="n">phdos_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">workdir</span><span class="p">,</span> <span class="s">&quot;run.abo_PHDOS.nc&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">phdos_path</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">status</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">S_OK</span><span class="p">:</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">critical</span><span class="p">(</span><span class="s">&quot;</span><span class="si">%s</span><span class="s"> reached S_OK but didn&#39;t produce a PHBST file in </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">outdir</span><span class="p">))</span>
            <span class="k">return</span> <span class="bp">None</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">PhdosFile</span><span class="p">(</span><span class="n">phdos_path</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">exc</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">critical</span><span class="p">(</span><span class="s">&quot;Exception while reading GSR file at </span><span class="si">%s</span><span class="s">:</span><span class="se">\n</span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">phdos_path</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">exc</span><span class="p">)))</span>
            <span class="k">return</span> <span class="bp">None</span></div>

<div class="viewcode-block" id="AnaddbTask.get_results"><a class="viewcode-back" href="../../../../pymatgen.io.abinit.html#pymatgen.io.abinit.tasks.AnaddbTask.get_results">[docs]</a>    <span class="k">def</span> <span class="nf">get_results</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">results</span> <span class="o">=</span> <span class="nb">super</span><span class="p">(</span><span class="n">AnaddbTask</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">get_results</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">results</span></div></div>
</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../../../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../../index.html">pymatgen 3.3.0 documentation</a> &raquo;</li>
          <li class="nav-item nav-item-1"><a href="../../../index.html" >Module code</a> &raquo;</li> 
      </ul>
    </div>

    <div class="footer" role="contentinfo">
        &copy; Copyright 2011, Pymatgen Development Team.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.3.3.
    </div>
<div class="footer">This page uses <a href="http://analytics.google.com/">
Google Analytics</a> to collect statistics. You can disable it by blocking
the JavaScript coming from www.google-analytics.com.
<script type="text/javascript">
  (function() {
    var ga = document.createElement('script');
    ga.src = ('https:' == document.location.protocol ?
              'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    ga.setAttribute('async', 'true');
    document.documentElement.firstChild.appendChild(ga);
  })();
</script>
</div>

  </body>
</html>